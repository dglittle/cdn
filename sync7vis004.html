
<script src="https://dglittle.github.io/cdn/random001.js"></script>
<script src="https://dglittle.github.io/cdn/utils004.js"></script>
<script src="https://invisible-college.github.io/universal-sync/diffsync.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"></script>
<script src="https://unpkg.com/d3-dag"></script>

<body style="margin:0px"></body>
<script>

Math.randomSeed(144)
    
var CHAR_BOX_SIZE = 20

function random_normal(mean, std_dev) {
    var x0 = 1.0 - Math.random()
    var x1 = 1.0 - Math.random()
    return Math.sqrt(-2.0 * Math.log(x0)) * Math.cos(2.0 * Math.PI * x1) * std_dev + mean
}

function clip (subjectPolygon, clipPolygon) {
    var cp1, cp2, s, e;
    var inside = function (p) {
        return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);
    };
    var intersection = function () {
        var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],
            dp = [ s[0] - e[0], s[1] - e[1] ],
            n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
            n2 = s[0] * e[1] - s[1] * e[0], 
            n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
        return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];
    };
    var outputList = subjectPolygon;
    cp1 = clipPolygon[clipPolygon.length-1];
    for (j in clipPolygon) {
        var cp2 = clipPolygon[j];
        var inputList = outputList;
        outputList = [];
        s = inputList[inputList.length - 1]; //last on the input list
        for (i in inputList) {
            var e = inputList[i];
            if (inside(e)) {
                if (!inside(s)) {
                    outputList.push(intersection());
                }
                outputList.push(e);
            }
            else if (inside(s)) {
                outputList.push(intersection());
            }
            s = e;
        }
        cp1 = cp2;
    }
    return outputList
}

function calcPolygonArea(vertices) {
    var total = 0

    for (var i = 0, l = vertices.length; i < l; i++) {
        var addX = vertices[i][0]
        var addY = vertices[i == vertices.length - 1 ? 0 : i + 1][1]
        var subX = vertices[i == vertices.length - 1 ? 0 : i + 1][0]
        var subY = vertices[i][1]
        
        total += (addX * addY * 0.5)
        total -= (subX * subY * 0.5)
    }

    return Math.abs(total)
}

function sync7_create_visualization(s7) {
    var selected = {}
    
    var d = document.createElement('div')
    
    var svg_div = document.createElement('div')
    svg_div.style.cursor = 'pointer'
    d.append(svg_div)

    function create_line(x1, y1, x2, y2, stroke) {
        var line = document.createElementNS('http://www.w3.org/2000/svg', 'line')
        line.setAttribute('x1', x1)
        line.setAttribute('y1', y1)
        line.setAttribute('x2', x2)
        line.setAttribute('y2', y2)
        line.setAttribute('stroke', stroke)
        return line
    }
    
    function calc_specials(id) {
        var specials = {}
        each(s7.commits[id].to_parents, function (d, p) {
            var offset = 0
            each(d, function (d) {
                if (typeof(d) == 'number') {
                    offset += d
                } else {
                    for (var i = 0; i < d[0].length; i++) {
                        specials[offset++] = true
                    }
                }
            })
        })
        return specials
    }
    
    function create_char_boxes(x, y, size, text, selected, specials, merge_node) {
        var stroke = 'black'
        var g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
        
        if (selected) {
            var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
            rect.style.fill = 'yellow'
            rect.setAttribute('x', x)
            rect.setAttribute('y', y)
            rect.setAttribute('width', text.length * size)
            rect.setAttribute('height', size)
            g.append(rect)
        }
        
        for (var i = 0; i < text.length; i++) {
            if (specials[i]) {
                var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
                rect.style.fill = merge_node ? 'rgba(180, 180, 180, 0.5)' : 'rgba(100, 255, 30, 0.5)'
                rect.setAttribute('x', x + i*size)
                rect.setAttribute('y', y)
                rect.setAttribute('width', size)
                rect.setAttribute('height', size)
                g.append(rect)
            }
        }
        
        g.append(create_line(x, y + 0.5, x + size * text.length, y + 0.5, stroke))
        g.append(create_line(x, y + size - 0.5, x + size * text.length, y + size - 0.5, stroke))
        for (var i = 0; i <= text.length; i++) {
            g.append(create_line(x + i * size + 0.5, y + 0.5, x + i * size + 0.5, y + size - 0.5, stroke))
        }
        for (var i = 0; i < text.length; i++) {
            var char = document.createElementNS('http://www.w3.org/2000/svg', 'text')
            char.style.fill = specials[i] ? (merge_node ? 'darkgrey' : 'rgb(0,130,0)') : 'darkgrey'
            char.style.fontSize = size
            char.setAttribute('x', Math.floor(x + i*size + size/2))
            char.setAttribute('y', y + size*0.9)
            char.setAttribute('text-anchor', 'middle')
            char.setAttribute('alignment-baseline', 'baseline')
            
            var textNode = document.createTextNode(text[i])
            char.appendChild(textNode)
            
            g.append(char)
        }
        return g
    }
    
    function create_polygon(points, fill) {
        var poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon')
        poly.style.fill = fill
        
        var points_text = []
        for (var i = 0; i < points.length; i++) {
            points_text.push((i == 0 ? '' : ' ') + points[i][0])
            points_text.push(',' + points[i][1])
        }
        poly.setAttribute('points', points_text.join(''))
        
        return poly
    }
    
    function create_diff_lines(x1, y1, x2, y2, size, diff, merge_node) {
        var stroke = 'black'
        var g = document.createElementNS('http://www.w3.org/2000/svg', 'g')

        var child_offset = 0
        var parent_offset = 0
        each(diff, function (d) {
            var points = []
            points.push([x1 + child_offset + 0.5, y1])
            points.push([x2 + parent_offset + 0.5, y2 + size])
            if (typeof(d) == 'number') {
                child_offset += d * size
                parent_offset += d * size
            } else {
                child_offset += d[0].length * size
                parent_offset += d[1].length * size
            }
            points.push([x2 + parent_offset + 0.5, y2 + size])
            points.push([x1 + child_offset + 0.5, y1])

            if (typeof(d) != 'number') {
                g.append(create_polygon(points, merge_node ? 'rgba(180, 180, 180, 0.5)' : 'rgba(100, 255, 30, 0.5)'))
            }
        })

        var child_offset = 0
        var parent_offset = 0
        g.append(create_line(x1 + child_offset, y1, x2 + parent_offset, y2 + size, stroke))
        each(diff, function (d) {
            if (typeof(d) == 'number') {
                child_offset += d * size
                parent_offset += d * size
            } else {
                child_offset += d[0].length * size
                parent_offset += d[1].length * size
            }
            g.append(create_line(x1 + child_offset + 0.5, y1, x2 + parent_offset + 0.5, y2 + size, stroke))
        })

        return g
    }

    var svg = null
    function redraw() {
        if (svg) svg.remove()
        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
        svg_div.append(svg)
        svg.setAttribute('width', s7.width)
        svg.setAttribute('height', s7.height)
        
        each(s7.commits, function (c, id) {
            var merge_node = Object.keys(c.to_parents).length > 1
            each(c.to_parents, function (d, pid) {
                svg.append(create_diff_lines(c.x || 0, c.y || 0, s7.commits[pid].x || 0, s7.commits[pid].y || 0, CHAR_BOX_SIZE, d, merge_node))
            })
        })
    
        each(s7.commits, function (c, id) {
            var merge_node = Object.keys(c.to_parents).length > 1
            svg.append(create_char_boxes(c.x || 0, c.y || 0, CHAR_BOX_SIZE, c.text || '', selected[id], calc_specials(id), merge_node))
        })
    }
    redraw()

    function getPos(e) {
        var x = 0, y = 0
        while (e != null) {
            x += e.offsetLeft
            y += e.offsetTop
            e = e.offsetParent
        }
        return {x : x, y : y}
    }
    
    function getRelPos(to, positionedObject) {
        var pos = getPos(to)
        return {
            x : positionedObject.pageX - pos.x,
            y : positionedObject.pageY - pos.y
        }
    }    
    
    svg_div.onmousedown = function (e) {
        e.preventDefault()
        var pos = getRelPos(svg_div, e)
        
        var grabbed = null
        each(s7.commits, function (c, id) {
            if (pos.x >= (c.x || 0) && pos.x < (c.x || 0) + (c.text || 'Q!?').length * CHAR_BOX_SIZE && pos.y >= (c.y || 0) && pos.y < (c.y || 0) + CHAR_BOX_SIZE) {
                if (!e.metaKey)
                    selected = {}
                selected[id] = true
                grabbed = {
                    id : id,
                    hot_x : pos.x - (c.x || 0),
                    hot_y : pos.y - (c.y || 0)
                }
                redraw()
                return false
            }
        })
        if (!grabbed) {
            selected = {}
            redraw()
        }

        var oldMove = document.onmousemove
        document.onmousemove = function (e) {
            var pos = getRelPos(svg_div, e)
            if (grabbed) {
                s7.commits[grabbed.id].x = pos.x - grabbed.hot_x
                s7.commits[grabbed.id].y = pos.y - grabbed.hot_y
                redraw()
            }
        }
        
        var oldUp = document.onmouseup
        document.onmouseup = function (e) {
            document.onmousemove = oldMove
            document.onmouseup = oldUp
        }
    }    

    return d
}






var sync7 = {}

    sync7.create = function () {
        return {
            commits : {
                'root' : { to_parents : {}, from_kids : {} }
            },
            temp_commits : {},
            real_leaves : ['root'],
            leaf : 'root',
            text : ''
        }
    }

    sync7.commit = function (s7, s) {
        if (s == s7.text) { return }
        
        var cs = s7.temp_commits
        s7.temp_commits = {}
    
        var id = guid()
        var to_parents = {}
        s7.commits[s7.leaf].from_kids[id] = to_parents[s7.leaf] = sync7_diff(s, s7.text)
        s7.commits[id] = cs[id] = { to_parents : to_parents, from_kids : {} }
        s7.leaf = id
        s7.real_leaves = [id]
        
        s7.text = s
        return cs
    }

    sync7.merge = function (s7, cs, cursors, custom_merge_func) {
        if (!cursors) cursors = {}
        if (!custom_merge_func) custom_merge_func = default_custom_merge_func
        var projected_cursors = map(cursors, function (cursor) {
            var node = s7.leaf
            while (s7.temp_commits[node]) {
                var old_node = node
                each(s7.commits[node].to_parents, function (d, p) {
                    var offset = 0
                    var poffset = 0
                    each(d, function (d) {
                        if (typeof(d) == 'number') {
                            if (cursor <= offset + d) {
                                cursor = cursor - offset + poffset
                                node = p
                                return false
                            }
                            offset += d
                            poffset += d
                        } else {
                            offset += d[0].length
                            poffset += d[1].length
                        }
                    })
                    if (old_node != node) return false
                })
                if (old_node == node) throw 'failed to project cursor up'
            }
            return [cursor, node]
        })

        each(cs, function (c, id) {
            s7.commits[id] = c
            each(c.to_parents, function (d, p) {
                if (!cs[p] && s7.commits[p]) {
                    s7.commits[p].from_kids[id] = d
                }
            })
        })
        s7.real_leaves = sync7_get_leaves(s7.commits, s7.temp_commits)
        var leaves = Object.keys(s7.real_leaves).sort()
        
        var texts = {}
        each(leaves, function (leaf) {
            texts[leaf] = sync7_get_text(s7, leaf)
        })
    
        each(s7.temp_commits, function (c, k) {
            each(c.to_parents, function (d, p) {
                if (!s7.temp_commits[p]) {
                    delete s7.commits[p].from_kids[k]
                }
            })
            delete s7.commits[k]
        })
        s7.temp_commits = {}
        
        var prev_merge_node = leaves[0]
        var ancestors = sync7_get_ancestors(s7, prev_merge_node)
        for (var i = 1; i < leaves.length; i++) {
            var leaf = leaves[i]
            var i_ancestors = sync7_get_ancestors(s7, leaf)
            var CAs = sync7_intersection(ancestors, i_ancestors)
            var LCAs = sync7_get_leaves(CAs)
            each(i_ancestors, function (v, k) {
                ancestors[k] = v
            })
            
            function get_nodes_on_path_to_LCAs(node) {
                var agg = {}
                function helper(x) {
                    var hit_LCA = LCAs[x]
                    if (!CAs[x]) {
                        each(s7.commits[x].to_parents, function (d, p) {
                            hit_LCA = helper(p) || hit_LCA
                        })
                    }
                    if (hit_LCA) {
                        agg[x] = true
                        return true
                    }
                }
                helper(node)
                return agg
            }
    
            function calc_dividers_and_such_for_node(node, nodes_on_path_to_LCAs, dividers, untouched_regions_for_node) {
                untouched_regions_for_node[node] = [[0, texts[node].length, 0]]
                function helper(node) {
                    if (untouched_regions_for_node[node]) return untouched_regions_for_node[node]
                    var pur = {}
                    each(s7.commits[node].from_kids, function (d, k) {
                        if (!nodes_on_path_to_LCAs[k]) { return }
                        var untouched = helper(k)
                        
                        var ui = 0
                        var uo = 0
                        var offset = 0
                        var poffset = 0
                        each(d, function (r) {
                            var end_point = offset + ((typeof(r) == 'number') ? r : r[0].length)
                            while (untouched[ui] && end_point >= untouched[ui][2] + untouched[ui][1]) {
                                if (typeof(r) == 'number') {
                                    var x = untouched[ui][2] + uo - offset + poffset
                                    pur[x] = [untouched[ui][0] + uo, untouched[ui][1] - uo, x]
                                }
                                ui++
                                uo = 0
                            }
                            if (!untouched[ui]) { return false }
                            if (end_point > untouched[ui][2] + uo) {
                                if (typeof(r) == 'number') {
                                    var x = untouched[ui][2] + uo - offset + poffset
                                    pur[x] = [untouched[ui][0] + uo, end_point - (untouched[ui][2] + uo), x]
                                }
                                uo = end_point - untouched[ui][2]
                                dividers[untouched[ui][0] + uo] = untouched[ui][0] + uo
                            }
                            offset = end_point
                            poffset += (typeof(r) == 'number') ? r : r[1].length
                        })
                    })
                    return untouched_regions_for_node[node] = Object.values(pur).sort(function (a, b) { return a[2] - b[2] })
                }
                each(LCAs, function (_, lca) { helper(lca) })
            }
    
            var prev_nodes_on_path_to_LCAs = get_nodes_on_path_to_LCAs(prev_merge_node)
            var prev_dividers = {}
            var prev_untouched_regions_for_node = {}
            calc_dividers_and_such_for_node(prev_merge_node, prev_nodes_on_path_to_LCAs, prev_dividers, prev_untouched_regions_for_node)
    
            var leaf_nodes_on_path_to_LCAs = get_nodes_on_path_to_LCAs(leaf)
            var leaf_dividers = {}
            var leaf_untouched_regions_for_node = {}
            calc_dividers_and_such_for_node(leaf, leaf_nodes_on_path_to_LCAs, leaf_dividers, leaf_untouched_regions_for_node)
            
            each(LCAs, function (_, lca) {
                function do_one_against_the_other(a, b, dividers) {
                    var bb, bi = 0
                    each(a, function (aa) {
                        while ((bb = b[bi]) && (bb[2] + bb[1] <= aa[2])) bi++
                        if (bb && bb[2] < aa[2]) {
                            var x = aa[2] - bb[2] + bb[0]
                            dividers[x] = x
                        }
                        while ((bb = b[bi]) && (bb[2] + bb[1] <= aa[2] + aa[1])) bi++
                        if (bb && bb[2] < aa[2] + aa[1]) {
                            var x = aa[2] + aa[1] - bb[2] + bb[0]
                            dividers[x] = x
                        }
                    })
                }
                
                var a = prev_untouched_regions_for_node[lca]
                var b = leaf_untouched_regions_for_node[lca]
                do_one_against_the_other(a, b, leaf_dividers)
                do_one_against_the_other(b, a, prev_dividers)
            })
            
            function calc_endpoints(dividers, node) {
                var endpoints = []
                endpoints.push([0, 0, 0])
                each(Object.values(dividers).sort(function (a, b) { return a - b }), function (offset) {
                    endpoints.push([offset, 1, offset])
                    endpoints.push([offset, 0, offset])
                })
                endpoints.push([texts[node].length, 1, texts[node].length])
                
                return endpoints
            }
            
            var prev_endpoints = calc_endpoints(prev_dividers, prev_merge_node)
            var leaf_endpoints = calc_endpoints(leaf_dividers, leaf)
    
            function project_endpoints_to_LCAs(endpoints, node, nodes_on_path_to_LCAs) {
                var endpoints_for_node = {}
                endpoints_for_node[node] = endpoints
    
                function helper(node) {
                    if (endpoints_for_node[node]) return endpoints_for_node[node]
                    var agg = {}
                    function add_to_agg(endpoint, projected_pos) {
                        var key = '[' + endpoint[0] + ',' + endpoint[1] + ']'
                        if (endpoint[1] == 0)
                            agg[key] = Math.min(agg[key] || Infinity, projected_pos)
                        else
                            agg[key] = Math.max(agg[key] || -Infinity, projected_pos)
                    }
                    each(s7.commits[node].from_kids, function (d, k) {
                        if (!nodes_on_path_to_LCAs[k]) { return }
                        
                        var endpoints = helper(k)
                        var ei = 0
                        
                        var offset = 0
                        var poffset = 0
                        each(d, function (d) {
                            var end = offset + ((typeof(d) == 'number') ? d : d[0].length)
                            while (endpoints[ei] && (endpoints[ei][2] < end || (endpoints[ei][1] == 1 && endpoints[ei][2] <= end))) {
                                if (typeof(d) == 'number') {
                                    add_to_agg(endpoints[ei], endpoints[ei][2] - offset + poffset)
                                } else if (endpoints[ei][1] == 0) {
                                    add_to_agg(endpoints[ei], poffset)
                                } else {
                                    add_to_agg(endpoints[ei], poffset + d[1].length)
                                }
                                ei++
                            }
                            offset = end
                            poffset += (typeof(d) == 'number') ? d : d[1].length
                        })
                        while (endpoints[ei]) {
                            add_to_agg(endpoints[ei], poffset)
                            ei++
                        }
                    })
                    
                    var endpoints = []
                    each(agg, function (v, k) {
                        var kk = eval(k)
                        endpoints.push([kk[0], kk[1], v])
                    })
                    
                    return endpoints_for_node[node] = endpoints.sort(function (a, b) {
                        if (a[2] != b[2])
                            return a[2] - b[2]
                        return b[1] - a[1]
                    })
                }
    
                var regions_for_node = {}
    
                var lookup_by_begin = {}
                var lookup_by_end = {}
                var base_regions = []
                regions_for_node[node] = base_regions
                for (var i = 0; i < endpoints.length; i += 2) {
                    var e0 = endpoints[i][0]
                    var e1 = endpoints[i + 1][0]
                    base_regions.push([e0, e1 - e0])
                    lookup_by_begin[e0] = base_regions.length - 1
                    lookup_by_end[e1] = base_regions.length - 1
                }
                
                each(LCAs, function (_, lca) {
                    var endpoints = helper(lca)
                    var regions = []
                    regions_for_node[lca] = regions
                    each(endpoints, function (e) {
                        if (e[1] == 0) {
                            var i = lookup_by_begin[e[0]];
                            (regions[i] = regions[i] || [])[0] = e[2]
                        } else {
                            var i = lookup_by_end[e[0]];
                            (regions[i] = regions[i] || [])[1] = e[2]
                        }
                    })
                    each(regions, function (r) {
                        r[1] = r[1] - r[0]
                    })
                })
    
                return regions_for_node
            }
            
            var prev_regions_per_node = project_endpoints_to_LCAs(prev_endpoints, prev_merge_node, prev_nodes_on_path_to_LCAs)
            var leaf_regions_per_node = project_endpoints_to_LCAs(leaf_endpoints, leaf, leaf_nodes_on_path_to_LCAs)
            
            var prev_regions = prev_regions_per_node[prev_merge_node]
            var leaf_regions = leaf_regions_per_node[leaf]
    
            var prev_untouched_regions_for_LCA_by_position = {}
            var leaf_untouched_regions_for_LCA_by_position = {}
    
            each(LCAs, function (_, lca) {
                function process(base, regions, untouched, _by_position) {
                    _by_position[lca] = {}
                    var ri = 0
                    var r
                    each(untouched, function (u) {
                        while ((r = regions[ri]) && r[0] + r[1] <= u[2]) { ri++ }
                        while ((r = regions[ri]) && r[0] < u[2] + u[1]) {
                            _by_position[lca][r[0]] = ri
                            base[ri][2] = true
                            r[2] = true
                            ri++
                        }
                    })
                }
                process(prev_regions_per_node[prev_merge_node], prev_regions_per_node[lca], prev_untouched_regions_for_node[lca], prev_untouched_regions_for_LCA_by_position)
                process(leaf_regions_per_node[leaf], leaf_regions_per_node[lca], leaf_untouched_regions_for_node[lca], leaf_untouched_regions_for_LCA_by_position)
            })
    
            function mark_deletes_and_more(regions_for_node, node, other_untouched_for_LCA_by_position) {
                each(regions_for_node[node], function (r, ri) {
                    r[4] = r[5] = -1 // <-- the "more"
                    if (r[2]) {
                        r[3] = -1
                        each(LCAs, function (_, lca) {
                            var rr = regions_for_node[lca][ri]
                            var other_ri = other_untouched_for_LCA_by_position[lca][rr[0]]
                            if (rr[2] && (typeof(other_ri) == 'number')) {
                                r[3] = other_ri
                                return false
                            }
                        })
                    }
                })
            }
            mark_deletes_and_more(prev_regions_per_node, prev_merge_node, leaf_untouched_regions_for_LCA_by_position)
            mark_deletes_and_more(leaf_regions_per_node, leaf, prev_untouched_regions_for_LCA_by_position)
    
            function is_definitely_before(a_regions, a_node, ai, b_regions, b_node, bi) {
                var a_before_b = false
                var b_before_a = false
                each(LCAs, function (_, lca) {
                    var ar = a_regions[lca][ai]
                    var br = b_regions[lca][bi]
                    
                    if ((ar[1] || br[1]) && (ar[0] + ar[1] <= br[0]))
                        a_before_b = true
                    if ((!ar[1] && !br[1]) && (ar[0] < br[0]))
                        a_before_b = true
                        
                    if ((ar[1] || br[1]) && (br[0] + br[1] <= ar[0]))
                        b_before_a = true
                    if ((!ar[1] && !br[1]) && (br[0] < ar[0]))
                        b_before_a = true
                })
                return a_before_b && !b_before_a
            }
            
            function calc_known_orderings(a_regions, a_node, b_regions, b_node) {
                var bi = 0
                each(a_regions[a_node], function (ar, ai) {
                    for ( ; bi < b_regions[b_node].length; bi++) {
                        if (is_definitely_before(a_regions, a_node, ai, b_regions, b_node, bi)) {
                            ar[4] = bi
                            b_regions[b_node][bi][5] = ai
                            return
                        }
                    }
                })
            }
            calc_known_orderings(prev_regions_per_node, prev_merge_node, leaf_regions_per_node, leaf)
            calc_known_orderings(leaf_regions_per_node, leaf, prev_regions_per_node, prev_merge_node)
    
            var m = custom_merge_func(s7, prev_merge_node, leaf, texts[prev_merge_node], texts[leaf], prev_regions, leaf_regions)
            
            var id = guid()
            var to_parents = {}
            s7.commits[prev_merge_node].from_kids[id] = to_parents[prev_merge_node] = m.to_a
            s7.commits[leaf].from_kids[id] = to_parents[leaf] = m.to_b
            s7.commits[id] = s7.temp_commits[id] = { to_parents : to_parents, from_kids : {} }
            
            prev_merge_node = id
            texts[prev_merge_node] = m.text
        }
    
        s7.leaf = prev_merge_node
        s7.text = texts[prev_merge_node]
        
        return map(projected_cursors, function (cursor) {
            while (cursor[1] != s7.leaf) {
                var old_node = cursor[1]
                var kids = s7.commits[cursor[1]].from_kids
                var kid = Object.keys(kids)[0]
                var d = kids[kid]

                var offset = 0
                var poffset = 0
                each(d, function (d) {
                    if (typeof(d) == 'number') {
                        if (cursor[0] <= poffset + d) {
                            cursor[0] = cursor[0] - poffset + offset
                            cursor[1] = kid
                            return false
                        }
                        offset += d
                        poffset += d
                    } else {
                        if (cursor[0] <= poffset + d[1].length) {
                            cursor[0] = offset
                            cursor[1] = kid
                            return false
                        }
                        offset += d[0].length
                        poffset += d[1].length
                    }
                })
                if (cursor[1] == old_node) {
                    cursor[0] = offset
                    cursor[1] = kid
                }
            }
            return cursor[0]
        })
    }

    function default_custom_merge_func(s7, a, b, a_text, b_text, a_regions, b_regions) {
        // regions be like [pos, len, untouched?, index in other region array of this untouched or -1 if not present, index of first region in other array that this region is definitely before, index of last region in other array that this region is definitely after]
        
        // console.log('HI!!')
        // console.log(a)
        // console.log(b)
        // console.log(a_text)
        // console.log(b_text)
        // console.log(a_regions)
        // console.log(b_regions)
    
        var text = []
        var a_diff = []
        var b_diff = []
        var on_a = true
        var ai = 0
        var bi = 0
        while (true) {
            var aa = a_regions[ai]
            var bb = b_regions[bi]
            if (!aa && !bb) break
            if (!aa) on_a = false
            if (!bb) on_a = true
            
            var ci = on_a ? ai : bi
            var di = on_a ? bi : ai
            var cc = on_a ? aa : bb
            var dd = on_a ? bb : aa
            var c_text = on_a ? a_text : b_text
            var d_text = on_a ? b_text : a_text
            var c_diff = on_a ? a_diff : b_diff
            var d_diff = on_a ? b_diff : a_diff
    
            if (cc[5] < di) {
                var t = c_text.substr(cc[0], cc[1])
                if (cc[2]) {
                    if (cc[3] < di) {
                        c_diff.push(['', t])
                    } else if (cc[3] == di) {
                        text.push(t)
                        sync7_push_eq(c_diff, cc[1])
                        sync7_push_eq(d_diff, cc[1])
                        if (on_a) { bi++ } else { ai++ }
                    } else {
                        text.push(t)
                        sync7_push_eq(c_diff, cc[1])
                        d_diff.push([t, ''])
                    }
                } else {
                    text.push(t)
                    sync7_push_eq(c_diff, cc[1])
                    d_diff.push([t, ''])
                }
                if (on_a) { ai++ } else { bi++ }
            } else if (dd && dd[5] < ci) {
                on_a = !on_a
            } else {
                throw 'failure'
            }
        }
    
        // console.log('HI!!!!!!')
        // console.log(text)
        // console.log(a_diff)
        // console.log(b_diff)
    
        return {
            text : text.join(''),
            to_a : a_diff,
            to_b : b_diff
        }
    }
    
    function sync7_diff_merge_trans(a, b, a_factor, b_factor) {
        var ret = []
        var a_i = 0
        var b_i = 0
        var a_offset = 0
        var b_offset = 0
        var a_dumped_load = false
        var b_dumped_load = false
        function neg_idx(i) {
            return i == 0 ? 1 : 0
        }
        function a_idx(i) {
            return a_factor == -1 ? neg_idx(i) : i
        }
        function b_idx(i) {
            return b_factor == -1 ? neg_idx(i) : i
        }
        while (a_i < a.length && b_i < b.length) {
            var da = a[a_i]
            var db = b[b_i]
            if (typeof(da) == 'number' && typeof(db) == 'number') {
                var a_len = da - a_offset
                var b_len = db - b_offset
                sync7_push_eq(ret, Math.min(a_len, b_len))
            } else if (typeof(da) == 'number') {
                var a_len = da - a_offset
                var b_len = db[b_idx(0)].length - b_offset
                sync7_push_rep(ret, db[b_idx(0)].substr(b_offset, Math.min(a_len, b_len)), !b_dumped_load ? db[b_idx(1)] : '')
                b_dumped_load = true
            } else if (typeof(db) == 'number') {
                var a_len = da[a_idx(1)].length - a_offset
                var b_len = db - b_offset
                sync7_push_rep(ret, !a_dumped_load ? da[a_idx(0)] : '', da[a_idx(1)].substr(a_offset, Math.min(a_len, b_len)))
                a_dumped_load = true
            } else {
                var a_len = da[a_idx(1)].length - a_offset
                var b_len = db[b_idx(0)].length - b_offset
                sync7_push_rep(ret, !a_dumped_load ? da[a_idx(0)] : '', !b_dumped_load ? db[b_idx(1)] : '')
                a_dumped_load = b_dumped_load = true
            }
            if (a_len > b_len) {
                a_offset += b_len
            } else {
                a_i++
                a_offset = 0
                a_dumped_load = false
            }
            if (a_len < b_len) {
                b_offset += a_len
            } else {
                b_i++
                b_offset = 0
                b_dumped_load = false
            }
        }
        while (a_i < a.length) {
            var da = a[a_i]
            if (typeof(da) == 'number') {
                sync7_push_eq(ret, da)
            } else {
                sync7_push_rep(ret, !a_dumped_load ? da[a_idx(0)] : '', da[a_idx(1)].substr(a_offset))
            }
            a_i++
            a_offset = 0
            a_dumped_load = false
        }
        while (b_i < b.length) {
            var db = b[b_i]
            if (typeof(db) == 'number') {
                sync7_push_eq(ret, db)
            } else {
                sync7_push_rep(ret, db[b_idx(0)].substr(b_offset), !b_dumped_load ? db[b_idx(1)] : '')
            }
            b_i++
            b_offset = 0
            b_dumped_load = false
        }
        return ret
    }


    
    function sync7_merge_path_up(s7, from, path) {
        var diff = []
        var prev = from
        each(path, function (next) {
            diff = sync7_diff_merge_trans(diff, s7.commits[prev].to_parents[next])
            prev = next
        })
        return diff
    }
    
    
    function sync7_get_text(s7, id) {
        var ls = sync7_get_leaves(sync7_intersection(sync7_get_ancestors(s7, s7.leaf, true), sync7_get_ancestors(s7, id, true)))
        var lca = Object.keys(ls)[0]
        var leaf_to_lca = sync7_get_path_to_ancestor(s7, s7.leaf, lca)
        var lca_to_id = sync7_get_path_to_ancestor(s7, id, lca).reverse()
        if (lca_to_id.length > 0) {
            lca_to_id.shift()
            lca_to_id.push(id)
        }
        
        var diff = sync7_merge_path_up(s7, s7.leaf, leaf_to_lca)
        var prev = lca
        each(lca_to_id, function (next) {
            diff = sync7_diff_merge_trans(diff, s7.commits[next].to_parents[prev], 1, -1)
            prev = next
        })
        
        return sync7_diff_apply(s7.text, diff)
    }
        
    function sync7_get_leaves(commits, ignore) {
        if (!ignore) ignore = {}
        var leaves = {}
        each(commits, function (_, id) {
            if (ignore[id]) { return }
            leaves[id] = true
        })
        each(commits, function (c, id) {
            if (ignore[id]) { return }
            each(c.to_parents, function (_, p) {
                delete leaves[p]
            })
        })
        return leaves
    }
    
    function sync7_get_ancestors(s7, id_or_set, include_self) {
        var frontier = null
        var ancestors = {}
        if (typeof(id_or_set) == 'object') {
            frontier = Object.keys(id_or_set)
            if (include_self) each(id_or_set, function (_, id) {
                ancestors[id] = s7.commits[id]
            })
        } else {
            frontier = [id_or_set]
            if (include_self) ancestors[id_or_set] = s7.commits[id_or_set]
        }
        while (frontier.length > 0) {
            var next = frontier.shift()
            each(s7.commits[next].to_parents, function (_, p) {
                if (!ancestors[p]) {
                    ancestors[p] = s7.commits[p]
                    frontier.push(p)
                }
            })
        }
        return ancestors
    }
    
    function sync7_get_path_to_ancestor(s7, a, b) {
        if (a == b) { return [] }
        var frontier = [a]
        var backs = {}
        while (frontier.length > 0) {
            var next = frontier.shift()
            if (next == b) {
                var path = []
                while (next && (next != a)) {
                    path.unshift(next)
                    next = backs[next]
                }
                return path
            }
            each(s7.commits[next].to_parents, function (_, p) {
                if (!backs[p]) {
                    backs[p] = next
                    frontier.push(p)
                }
            })
        }
        throw 'no path found from ' + a + ' to ' + b
    }
    
    function sync7_intersection(a, b) {
        var common = {}
        each(a, function (_, x) {
            if (b[x]) {
                common[x] = a[x]
            }
        })
        return common
    }
    
    function sync7_diff(a, b) {
        var ret = []
        var d = diff_main(a, b)
        for (var i = 0; i < d.length; i++) {
            var top = ret[ret.length - 1]
            if (d[i][0] == 0) {
                ret.push(d[i][1].length)
            } else if (d[i][0] == 1) {
                if (top && (typeof(top) != 'number'))
                    top[1] += d[i][1]
                else
                    ret.push(['', d[i][1]])
            } else {
                if (top && (typeof(top) != 'number'))
                    top[0] += d[i][1]
                else
                    ret.push([d[i][1], ''])
            }
        }
        return ret
    }
    
    function sync7_push_eq(diffs, size) {
        if (typeof(diffs[diffs.length - 1]) == 'number') {
            diffs[diffs.length - 1] += size
        } else diffs.push(size)
    }
    
    function sync7_push_rep(diffs, del, ins) {
        if (del.length == 0 && ins.length == 0) { return }
        if (diffs.length > 0) {
            var top = diffs[diffs.length - 1]
            if (typeof(top) != 'number') {
                top[0] += del
                top[1] += ins
                return
            }
        }
        diffs.push([del, ins])
    }
    
    function sync7_diff_apply(s, diff) {
        var offset = 0
        var texts = []
        each(diff, function (d) {
            if (typeof(d) == 'number') {
                texts.push(s.substr(offset, d))
                offset += d
            } else {
                texts.push(d[1])
                offset += d[0].length
            }
        })
        texts.push(s.substr(offset))
        return texts.join('')
    }
    
    function guid() {
        var x = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        var s = []
        for (var i = 0; i < 15; i++) {
            s.push(x[Math.floor(Math.random() * x.length)])
        }
        return s.join('')
    }

    function each(o, cb) {
        if (o instanceof Array) {
            for (var i = 0; i < o.length; i++) {
                if (cb(o[i], i, o) == false)
                    return false
            }
        } else {
            for (var k in o) {
                if (o.hasOwnProperty(k)) {
                    if (cb(o[k], k, o) == false)
                        return false
                }
            }
        }
        return true
    }

    function map(o, func) {
        if (o instanceof Array) {
            var accum = []
            for (var i = 0; i < o.length; i++)
                accum[i] = func(o[i], i, o)
            return accum
        } else {
            var accum = {}
            for (var k in o)
                if (o.hasOwnProperty(k))
                    accum[k] = func(o[k], k, o)
            return accum
        }
    }










function create_random_text() {
    var random_text = ''
    function add_char() {
        random_text += String.fromCharCode(97 + Math.floor(Math.random() * 26))
    }
    while (Math.random() < 0.75) add_char()
    return random_text
}

function create_random_ops() {
    var ops = []
    function add_random_ops() {
        if (Math.random() < 0.33) {
            ops.push({
                op : 'commit',
                side : Math.random() < 0.33 ? 'a' :
                    Math.random() < 0.5 ? 'b' : 'c',
                pos : Math.random(),
                del : Math.random(),
                text : create_random_text()
            })
        } else {
            ops.push({
                op : 'merge',
                side : Math.random() < 0.33 ? 'a' :
                    Math.random() < 0.5 ? 'b' : 'c'
            })
        }
    }
    add_random_ops()
    while (Math.random() < 0.9) add_random_ops()
    return ops
}

function apply_ops_to_sync7(s7s, ops, debug_print_buffer) {
    if (!s7s.a.buffer) s7s.a.buffer = []
    if (!s7s.b.buffer) s7s.b.buffer = []
    if (!s7s.c.buffer) s7s.c.buffer = []
    if (typeof(s7s.a.cursor) != 'number') s7s.a.cursor = 0
    if (typeof(s7s.b.cursor) != 'number') s7s.b.cursor = 0
    if (typeof(s7s.c.cursor) != 'number') s7s.c.cursor = 0
    each(ops, function (op, opi) {
        var s7 = s7s[op.side]
        var other_s7s = []
        each(s7s, function (s7, key) {
            if (key != op.side)
                other_s7s.push(s7)
        })
        if (op.op == 'commit') {
            var t = s7.text
            var pos = Math.floor((t.length + 1) * op.pos)
            var del = Math.floor((t.length - pos) * op.del)
            var msg = sync7.commit(s7, t.slice(0, pos) + op.text + t.slice(pos + del))
            if (!msg) msg = null
            each(other_s7s, function (s7) {
                s7.buffer.push(JSON.parse(JSON.stringify(msg)))
            })
            
            if (s7.cursor > s7.text.length) {
                s7.cursor = s7.text.length
            }
            
            if (debug_print_buffer) {
                debug_print_buffer.push('OP COMMIT')
                debug_print_buffer.push('side: ' + op.side)
                debug_print_buffer.push('pos: ' + pos)
                debug_print_buffer.push('del: ' + del)
                debug_print_buffer.push('txt: ' + op.text)
            }
            
        } else if (op.op == 'merge') {
            var x = s7.buffer.shift()
            if (x) {
                s7.cursor = sync7.merge(s7, x, null, default_custom_merge_func)
            }

            if (debug_print_buffer) {
                debug_print_buffer.push('OP MERGE')
                debug_print_buffer.push('side: ' + op.side)
            }
        }
    })
}

while (true) {
    var s7s = {
        a : sync7.create(),
        b : sync7.create(),
        c : sync7.create(),
    }
    var ops = create_random_ops()
    var buf = []
    apply_ops_to_sync7(s7s, ops, buf)
    
    var s7 = s7s.a
    if (Object.keys(s7.commits).length < 6) {
        console.log('trying again.. ' + Object.keys(s7.commits).length)
        continue
    } else {
        
        
        
        //console.log('buf = ' + buf.join('\n'))
        each(s7.commits, function (c, id) {
            c.text = sync7_get_text(s7, id)
        })
        
        
        
        
        // All we need to do then is to plug our dag into this grapho phormat -- s7.commits
        
        
        var grapho = []
        each(s7.commits, function (c, id) {
            grapho.push({
                id : id,
                parentIds : Object.keys(c.to_parents)
            })
        })
        
        
        
        
        var grafo = [{"id":"0","parentIds":[]},{"id":"1","parentIds":["0"]},{"id":"2","parentIds":["0"]}]
        
        grafo = grapho
        
        const dag = d3.dratify()(grafo)
        
        console.log(JSON.stringify(dag))
        
        d3.sugiyama()(dag);

        console.log('BLAH!')
        console.log(dag)
        
        const links = dag.links()
        const descendants = dag.descendants();
        
        
        // console.log('links: ' + JSON.stringify(links, null, '    '))
        // console.log('descendants: ' + JSON.stringify(descendants, null, '    '))
              
        

        var max_x = 0
        var max_y = 0



        var layers = {}
        each(descendants, function (d) {
            var layer = layers[d.layer] || { agg : 0, first : true, members : {} }
            layers[d.layer] = layer
            var text_len = s7.commits[d.id].text.length
            layer.members[d.id] = {
                size : text_len,
                node : d
            }
            layer.agg += text_len * CHAR_BOX_SIZE + (!layer.first ? CHAR_BOX_SIZE * 2.7 : 0)
            layer.first = false
            if (layer.agg > max_x)
                max_x = layer.agg
        })

        each(layers, function (layer, i) {
            var elements = []
            each(layer.members, function (member, id) {
                elements.push(member)
            })
            elements.sort(function (a, b) {
                return a.node.x - b.node.x
            })
            
            var offset = (max_x - layer.agg) / 2
            each(elements, function (e) {
                e.node.x = offset
                offset += e.size * CHAR_BOX_SIZE + CHAR_BOX_SIZE * 2.7
            })
            
        })

        each(descendants, function (descendant) {
            s7.commits[descendant.id].x = descendant.x
            s7.commits[descendant.id].y = descendant.y * 500
            
                if (s7.commits[descendant.id].y > max_y)
                    max_y = s7.commits[descendant.id].y + CHAR_BOX_SIZE
        })

        
        s7.width = max_x
        s7.height = max_y
        
        

        document.body.innerHTML = ''
        document.body.append(sync7_create_visualization(s7))
        break
    }
}


// different colors for different peers
// make mousing over a node transparentize everything else

// we want to time to flow down
// keep things from being too close (repel)
// black letter -> dark green (just the ones in the green spots)
// borders of diff-patch-things should be consistent with the colors of the letters
// get rid of interior walls, expect where there are patch boundaries (and get rid of ceilings)
// make floors of versions dotted (and thin)
// sans serif font
// want to see bottoms of letters inside boxes
// colored ones bold, and unchanged regions 

// optimize for test environment to be fun/interating
// have nice way for people to play with it

// add pruning and time collapse




// Done........ done-dy done done done........

// try edits coming from merges to be grey
// make it faster and better at laying out
// make it centered.. and make the size of it known to the scrolling interface

// Not done, but not on the list anymore

// optimize for every peer to have own column (might be the same from parents being near childre)n
// iterative optimization look into "force-directed layout" (d3 dag may use these)

</script>
