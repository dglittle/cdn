
<script src="https://dglittle.github.io/cdn/random001.js"></script>
<script src="https://dglittle.github.io/cdn/utils004.js"></script>
<script src="https://invisible-college.github.io/universal-sync/diffsync.js"></script>
<body></body>
<script>

// goal: compare speed with diffsync

function run_trial_sync9(seed, N) {
    var last_seed = seed
    function rand() {
        Math.randomSeed(last_seed)
        return last_seed = Math.random()
    }

    var n_clients = 2
    var clients = {}
    
    var server = sync9_create_server({
        add_version: (uid, vid, parents, changes) => {
            clients[uid].incoming.push(() => {
                clients[uid].add_version(vid, parents, changes)
            })
        },
        ack: (uid, vid) => {
            clients[uid].incoming.push(() => {
                clients[uid].ack(vid)
            })
        }
    })
    
    for (var i = 0; i < n_clients; i++) {
        ;(() => {
            var c = sync9_create_client({
                join : (uid, leaves) => {
                    c.outgoing.push(() => {
                        server.join(uid, leaves)
                    })
                },
                add_version : (uid, vid, parents, changes) => {
                    if (c.state == 'connected') {
                        c.outgoing.push(() => {
                            server.add_version(uid, vid, parents, changes)
                        })
                    }
                },
                ack : (uid, vid) => {
                    if (c.state == 'connected') {
                        c.outgoing.push(() => {
                            server.ack(uid, vid)
                        })
                    }
                }
            })
            c.state = 'disconnected'
            c.incoming = []
            c.outgoing = []
            clients[c.uid] = c
            
            if (i == 0) {
                c.letters = 'abcdefghijklmnopqrstuvwxyz'
                for (var ii = 0; ii < 100; ii++) {
                    c.letters += String.fromCharCode(12032 + ii)
                }
                c.letters_i = 0
            } else {
                c.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                for (var ii = 0; ii < 100; ii++) {
                    c.letters += String.fromCharCode(12032 + 100 + ii)
                }
                c.letters_i = 0
            }
        })()
    }
    
    for (var t = 0; t < N; t++) {
        var i = Math.floor(rand() * n_clients)
        var c = Object.values(clients)[i]
    
    
    
        var val = rand()
        console.log(val)
    
    
        if (rand() < 0.1) {
            console.log('got here!1')
            if (rand() < 0.9) {
                console.log('got here!2')
                if (c.letters_i >= c.letters.length) {
                    c.letters_i = 0
                }
                var edit = create_random_edit(c.s9, c.letters[c.letters_i++])
                console.log('edit: ', edit)
                var x = c.local_add_version(edit.changes)
            } else {
                if (c.state == 'disconnected') {
                    c.state = 'connected'
                    c.join()
                } else if (c.state == 'connected') {
                    c.state = 'disconnected'
                    c.state_note = 'had been connected'
                    c.incoming = []
                    c.outgoing = []
                    server.leave(c.uid)
                }
            }
        } else {
            if (rand() < 0.5) {
                if (c.incoming.length > 0) {
                    c.incoming.shift()()
                }
            } else {
                if (c.outgoing.length > 0) {
                    c.outgoing.shift()()
                }
            }
        }
    }
    
    for (var t = 0; t < 10000; t++) {
        Object.values(clients).forEach(c => {
            if (c.state == 'disconnected') {
                c.state = 'connected'
                c.join()
            }
            while (c.incoming.length > 0) {
                c.incoming.shift()()
            }
            while (c.outgoing.length > 0) {
                c.outgoing.shift()()
            }
        })
        
        if (Object.values(clients).every(x => x.incoming.length == 0 && x.outgoing.length == 0)) break
    }
    
    Object.values(clients).forEach(c => {
        c.add_version(sync9_guid(), c.s9.leaves, [])
    })
    
    var check_val = null
    var check_good = true
    ;[server].concat(Object.values(clients)).forEach((x, i) => {
        var val = sync9_read(x.s9)
        if (i == 0)
            check_val = val
        else if (val != check_val)
            check_good = false
    })
    
    if (!check_good) {
        ;[server].concat(Object.values(clients)).forEach((x, i) => {
            console.log(x)
            var val = sync9_read(x.s9)
            console.log(val)
        })
        console.log('CHECK GOOD: ' + check_good)
        throw 'stop'
    }

    function create_random_edit(s, letters) {
        letters = letters || 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        var str = sync9_read(s)
        var start = Math.floor(rand() * (str.length + 1))
        var del = Math.floor(rand() * rand() * (str.length - start + 1))
        var ins = letters[Math.floor(rand() * letters.length)].repeat(Math.floor(rand() * 4) + (del == 0 ? 1 : 0))
        
        var vid = sync9_guid()
        var changes = [`[${start}:${start + del}] = ` + JSON.stringify(ins)]
        
        return {
            vid : vid,
            parents : Object.assign({}, s.leaves),
            changes : changes
        }
    }
    
    console.log('done: ' + seed + ' : ' + sync9_read(server.s9))
}

function main() {
    var s = Date.now()
    run_trial_sync9('hiseedd', 500)
    var e = Date.now()
    console.log('time: ' + (e - s)/1000 + 's')
}






















function sync9_create_client(s_funcs) {
    var c = {}
    
    function init() {
        c.s9 = sync9_create()
        
        sync9_add_version(c.s9, 'v1', {root: true}, [' = ""'])
        sync9_prune(c.s9, (a, b) => true, (a, b) => true)
        delete c.s9.T.v1
        c.s9.leaves = {root: true}
    }
    init()
    
    c.uid = sync9_guid()
    c.server_leaves = {root: true}
    c.unacked = []
    c.delete_us = {}
    c.got_first_version = false
    
    c.join = () => {
        s_funcs.join(c.uid, c.server_leaves)
        c.unacked.forEach(x => s_funcs.add_version(c.uid, x.vid, x.parents, x.changes))
    }
    
    c.add_version = (vid, parents, changes) => {
        if (Object.keys(c.delete_us).length > 0) {
            var deleted = sync9_prune(c.s9, (a, b) => c.delete_us[b], (a, b) => c.delete_us[a])
            if (!Object.keys(c.delete_us).every(x => deleted[x])) throw 'wtf?'
            if (!Object.keys(deleted).every(x => c.delete_us[x])) throw 'wtf?'
            c.delete_us = {}
        }
        
        Object.keys(parents).forEach(p => {
            delete c.server_leaves[p]
        })
        c.server_leaves[vid] = true
        
        if (c.s9.T[vid]) {
            var v = c.unacked.shift()
            if (v.vid != vid) throw 'how?'
            return
        }
        
        if (!c.got_first_version) {
            c.got_first_version = true
            var save = sync9_read(c.s9)
            init()
            sync9_add_version(c.s9, vid, parents, changes)
            c.local_add_version(['[0:0]=' + JSON.stringify(save)])
        } else {
            sync9_add_version(c.s9, vid, parents, changes)
        }
        s_funcs.ack(c.uid, vid)
    }
    
    c.ack = (vid) => {
        s_funcs.ack(c.uid, vid)
        if (!c.s9.T[vid]) return
        
        c.delete_us[vid] = true
        
        if (c.server_leaves[vid]) {
            var ancs = sync9_get_ancestors(c.s9, c.server_leaves)
            Object.keys(c.delete_us).forEach(x => {
                delete ancs[x]
            })
            var not_leaves = {}
            Object.keys(ancs).forEach(x => {
                Object.assign(not_leaves, c.s9.T[x])
            })
            c.server_leaves = {}
            Object.keys(ancs).forEach(x => {
                if (!not_leaves[x])
                    c.server_leaves[x] = true
            })
        }
        
        c.unacked = c.unacked.filter(x => x.vid != vid)
    }
    
    c.local_add_version = (changes) => {
        var x = {
            vid : sync9_guid(),
            parents : Object.assign({}, c.s9.leaves),
            changes : changes
        }
        sync9_add_version(c.s9, x.vid, c.s9.leaves, x.changes)
        if (c.got_first_version) {
            c.unacked.push(x)
            s_funcs.add_version(c.uid, x.vid, x.parents, x.changes)
        }
        return x
    }
    
    return c
}

function sync9_create_server(c_funcs) {
    var s = {}
    
    s.s9 = sync9_create()
    sync9_add_version(s.s9, 'v1', {root : true}, [' = ""'])

    s.peers = {}
    s.prune_info = {
        root: {sent: {}, acked: {}},
        v1: {sent: {}, acked: {}}
    }
    
    function prune() {
        var q = (a, b) => (a != 'root') && !s.s9.leaves[b] && Object.keys(s.prune_info[a].sent).every(x => s.prune_info[b].acked[x])
        
        var clone = JSON.parse(JSON.stringify(s.s9))
        var deleted = sync9_prune2(clone, q, q)
        
        while (Object.keys(deleted).length > 0) {
            var clone = JSON.parse(JSON.stringify(s.s9))
            var deleted2 = sync9_prune2(clone, (a, b) => q(a, b) && deleted[b], (a, b) => q(a, b) && deleted[a])
            
            if (Object.keys(deleted).some(x => !deleted2[x])) {
                deleted = deleted2
            } else {
                break
            }
        }

        var backup_parents = {}
        Object.keys(deleted).forEach(x => backup_parents[x] = s.s9.T[x])

        var deleted2 = sync9_prune2(s.s9, (a, b) => q(a, b) && deleted[b], (a, b) => q(a, b) && deleted[a])
        
        if (Object.keys(deleted).some(x => !deleted2[x]) || Object.keys(deleted2).some(x => !deleted[x])) {
            throw 'wtf?'
        }
        
        Object.keys(deleted).forEach(deleted => {
            Object.entries(s.peers).forEach(x => {
                if (s.prune_info[deleted].sent[x[0]]) {
                    s.peers[x[0]].unacked_prunes[deleted] = backup_parents[deleted]
                }
                if (x[1].online) {
                    c_funcs.ack(x[0], deleted)
                }
            })
            delete s.prune_info[deleted]
        })
    }
    
    s.join = (uid, leaves) => {
        var p = s.peers[uid]
        if (!p) s.peers[uid] = p = {unacked_prunes: {}}
        p.online = true
        
        Object.keys(p.unacked_prunes).forEach(x => c_funcs.ack(uid, x))
        
        var ancs = {}
        function mark_ancs(key) {
            if (!ancs[key]) {
                ancs[key] = true
                Object.keys(s.s9.T[key] || p.unacked_prunes[key]).forEach(k => mark_ancs(k))
            }
        }
        Object.keys(leaves).forEach(k => mark_ancs(k))
        
        sync9_extract_versions(s.s9, x => ancs[x], x => true).forEach(x => {
            c_funcs.add_version(uid, x.vid, x.parents, x.changes)
            s.prune_info[x.vid].sent[uid] = true
        })
    }
    
    s.add_version = (uid, vid, parents, changes) => {
        if (s.s9.T[vid]) return
        
        var p = s.peers[uid]
        if (p.unacked_prunes[vid]) return
        
        s.prune_info[vid] = {sent: {}, acked: {[uid]: true}}
        
        Object.keys(parents).forEach(x => {
            if (p.unacked_prunes[x]) {
                delete parents[x]
                function helper(x) {
                    Object.keys(p.unacked_prunes[x]).forEach(x => {
                        if (p.unacked_prunes[x]) helper(x)
                        else parents[x] = true
                    })
                }
                helper(x)
            }
        })
         
        sync9_add_version(s.s9, vid, parents, changes)
        Object.entries(s.peers).forEach(x => {
            if (x[1].online) {
                c_funcs.add_version(x[0], vid, parents, changes)
                s.prune_info[vid].sent[x[0]] = true
            }
        })
        
        var ancs = sync9_get_ancestors(s.s9, parents)
        Object.keys(ancs).forEach(x => {
            var pi = s.prune_info[x]
            if (pi) pi.acked[uid] = true
        })
        
        prune()
    }
    
    s.ack = (uid, vid) => {
        var p = s.peers[uid]
        if (p.unacked_prunes[vid]) {
            delete p.unacked_prunes[vid]
            return
        }
        s.prune_info[vid].acked[uid] = true
        prune()
    }
    
    s.leave = (uid) => {
        var p = s.peers[uid]
        if (p) p.online = false
    }
    
    return s
}

function sync9_prune2(x, has_everyone_whos_seen_a_seen_b, has_everyone_whos_seen_a_seen_b_2) {
    var seen_nodes = {}
    var did_something = true
    function rec(x) {
        if (x && typeof(x) == 'object') {
            if (!x.t && x.val) {
                rec(x.val)
            } else if (x.t == 'val') {
                if (sync9_space_dag_prune2(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
                rec(sync9_space_dag_get(x.S, 0))
            } else if (x.t == 'obj') {
                Object.values(x.S).forEach(v => rec(v))
            } else if (x.t == 'arr') {
                if (sync9_space_dag_prune2(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
                sync9_trav_space_dag(x.S, () => true, node => {
                    node.elems.forEach(e => rec(e))
                })
            } else if (x.t == 'str') {
                if (sync9_space_dag_prune2(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
            }
        }
    }
    while (did_something) {
        did_something = false
        rec(x)
    }

    var visited = {}    
    var delete_us = {}
    function f(vid) {
        if (visited[vid]) return
        visited[vid] = true
        Object.keys(x.T[vid]).forEach(pid => {
            if (has_everyone_whos_seen_a_seen_b_2(pid, vid) && !seen_nodes[pid]) {
                delete_us[pid] = true
            }
            f(pid)
        })
    }
    Object.keys(x.leaves).forEach(f)

    var visited = {}
    var forwards = {}
    function g(vid) {
        if (visited[vid]) return
        visited[vid] = true
        if (delete_us[vid])
            forwards[vid] = {}
        Object.keys(x.T[vid]).forEach(pid => {
            g(pid)
            if (delete_us[vid]) {
                if (delete_us[pid])
                    Object.assign(forwards[vid], forwards[pid])
                else
                    forwards[vid][pid] = true
            } else if (delete_us[pid]) {
                delete x.T[vid][pid]
                Object.assign(x.T[vid], forwards[pid])
            }
        })
    }
    Object.keys(x.leaves).forEach(g)
    Object.keys(delete_us).forEach(vid => delete x.T[vid])
    return delete_us
}

function sync9_space_dag_prune2(S, has_everyone_whos_seen_a_seen_b, seen_nodes) {
    function set_nnnext(node, next) {
        while (node.next) node = node.next
        node.next = next
    }
    function process_node(node, offset, vid, prev) {
        var nexts = node.nexts
        var next = node.next
        
        var all_nexts_prunable = nexts.every(x => has_everyone_whos_seen_a_seen_b(vid, x.vid))
        if (nexts.length > 0 && all_nexts_prunable) {
            var first_prunable = 0
            var gamma = next
            if (first_prunable + 1 < nexts.length) {
                gamma = sync9_create_space_dag_node(null, typeof(node.elems) == 'string' ? '' : [])
                gamma.nexts = nexts.slice(first_prunable + 1)
                gamma.next = next
            }
            if (first_prunable == 0) {
                if (nexts[0].elems.length == 0 && !nexts[0].end_cap && nexts[0].nexts.length > 0) {
                    var beta = gamma
                    if (nexts[0].next) {
                        beta = nexts[0].next
                        set_nnnext(beta, gamma)
                    }
                    node.nexts = nexts[0].nexts
                    node.next = beta
                } else {
                    delete node.end_cap
                    node.nexts = []
                    node.next = nexts[0]
                    node.next.vid = null
                    set_nnnext(node, gamma)
                }
            } else {
                node.nexts = nexts.slice(0, first_prunable)
                node.next = nexts[first_prunable]
                node.next.vid = null
                set_nnnext(node, gamma)
            }
            return true
        }
        
        if (Object.keys(node.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k)) && all_nexts_prunable) {
            node.deleted_by = {}
            node.elems = typeof(node.elems) == 'string' ? '' : []
            delete node.gash
            return true
        } else {
            Object.assign(seen_nodes, node.deleted_by)
        }
        
        if (next && !next.nexts[0] && (Object.keys(next.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k)) || next.elems.length == 0)) {
            node.next = next.next
            return true
        }
        
        if (nexts.length == 0 && next &&
            !(next.elems.length == 0 && !next.end_cap && next.nexts.length > 0) &&
            Object.keys(node.deleted_by).every(x => next.deleted_by[x]) &&
            Object.keys(next.deleted_by).every(x => node.deleted_by[x])) {
            node.elems = node.elems.concat(next.elems)
            node.end_cap = next.end_cap
            node.nexts = next.nexts
            node.next = next.next
            return true
        }
    }
    var did_something = false
    sync9_trav_space_dag(S, () => true, (node, offset, has_nexts, prev, vid) => {
        if (!prev) seen_nodes[vid] = true
        while (process_node(node, offset, vid, prev)) {
            did_something = true
        }
    }, true)
    return did_something
}

function sync9_extract_versions(x, is_anc, is_new_anc) {
    var versions = sync9_space_dag_extract_versions(sync9_space_dag_get(x.val.S, 0).S, x, is_anc, is_new_anc)
    versions.forEach(x => {
        x.changes = x.splices.map(x => {
            return `[${x[0]}:${x[0] + x[1]}] = ${JSON.stringify(x[2])}`
        })
        delete x.splices
    })
    return versions
}

function sync9_space_dag_extract_versions(S, s9, is_anc, is_new_anc) {
    var versions = Object.keys(s9.T).filter(x => !is_anc(x) && is_new_anc(x)).map(vid => {
        var v = {
            vid,
            parents : Object.assign({}, s9.T[vid]),
            splices : []
        }
        
        function add_result(offset, del, ins) {
            if (v.splices.length > 0) {
                var prev = v.splices[v.splices.length - 1]
                if (prev[0] + prev[1] == offset) {
                    prev[1] += del
                    prev[2] = prev[2].concat(ins)
                    return
                }
            }
            v.splices.push([offset, del, ins])
        }
        
        var ancs = sync9_get_ancestors(s9, {[vid]: true})
        delete ancs[vid]
        var offset = 0
        function helper(node, vid) {
            if (vid == v.vid) {
                add_result(offset, 0, node.elems.slice(0))
            } else if (node.deleted_by[v.vid]) {
                add_result(offset, node.elems.length, node.elems.slice(0, 0))
            }
            
            if (ancs[vid] && !Object.keys(node.deleted_by).some(x => ancs[x])) {
                offset += node.elems.length
            }
                
            for (var next of node.nexts)
                helper(next, next.vid)
            if (node.next) helper(node.next, vid)
        }
        helper(S, S.vid)
        return v
    })
    
    var sorted = []
    var seen = {}
    while (versions.length > 0)
        versions = versions.filter(v => {
            if (Object.keys(v.parents).every(x => is_anc(x) || seen[x])) {
                seen[v.vid] = true
                sorted.push(v)
                return false
            } return true
        })
    return sorted
}

function sync9_create() {
    return {
        T: {root : {}},
        leaves: {root: true},
        val: sync9_create_val()
    }
}

function sync9_add_version(x, vid, parents, changes, is_anc) {
    if (x.T[vid]) return
    x.T[vid] = Object.assign({}, parents)
    
    Object.keys(parents).forEach(k => {
        if (x.leaves[k]) delete x.leaves[k]
    })
    x.leaves[vid] = true
    
    if (!is_anc) {
        if (parents == x.leaves) {
            is_anc = (_vid) => _vid != vid
        } else {
            var ancs = sync9_get_ancestors(x, parents)
            is_anc = _vid => ancs[_vid]
        }
    }
    
    changes.forEach(change => {
        var parse = sync9_parse_change(change)
        var cur = x.val
        each(parse.keys, (key, i) => {
            if (cur.t == 'val') cur = sync9_space_dag_get(cur.S, 0, is_anc)
            if (!cur) throw 'bad'
            if (typeof(key) == 'string' && cur.t == 'obj') {
                if (!cur.S[key]) cur.S[key] = sync9_create_val()
                cur = cur.S[key]
            } else if (typeof(key) == 'number') {
                if (i == parse.keys.length - 1) {
                    parse.range = [key, key + 1]
                    parse.val = [parse.val]
                } else if (i < parse.keys.length - 1 && cur.t == 'arr') {
                    cur = sync9_space_dag_get(cur.S, key, is_anc)
                } else throw 'bad'
            } else {
                throw 'bad'
            }
        })
        if (!parse.range) {
            if (cur.t != 'val') throw 'bad'
            sync9_space_dag_add_version(cur.S, vid, [[0, 0, [sync9_wrap(parse.val, vid)]]], is_anc)
        } else {
            if (cur.t == 'val') cur = sync9_space_dag_get(cur.S, 0, is_anc)
            if (parse.val instanceof Array && cur.t != 'arr') throw 'bad'
            if (parse.val instanceof String && cur.t != 'str') throw 'bad'
            if (parse.val instanceof Array) parse.val = parse.val.map(x => sync9_wrap(x, vid))
            sync9_space_dag_add_version(cur.S, vid, [[parse.range[0], parse.range[1] - parse.range[0], parse.val]], is_anc)
        }
    })
}

function sync9_read(x) {
    if (x && typeof(x) == 'object') {
        if (!x.t && x.val) return sync9_read(x.val)
        if (x.t == 'val') return sync9_read(sync9_space_dag_get(x.S, 0))
        if (x.t == 'obj') {
            var o = {}
            Object.entries(x.S).forEach(([k, v]) => {
                o[k] = sync9_read(v)
            })
            return o
        }
        if (x.t == 'arr') {
            var a = []
            sync9_trav_space_dag(x.S, () => true, (node) => {
                node.elems.forEach((e) => {
                    a.push(sync9_read(e))
                })
            })
            return a
        }
        if (x.t == 'str') {
            var s = []
            sync9_trav_space_dag(x.S, () => true, (node) => {
                s.push(node.elems)
            })
            return s.join('')
        }
    } return x
}

function sync9_wrap(x, vid) {
    if (typeof(x) == 'number') {
        return x
    } else if (typeof(x) == 'string') {
        var s = sync9_create_str()
        sync9_space_dag_add_version(s.S, vid, [[0, 0, x]], _vid => _vid != vid)
        return s
    } else if (typeof(x) == 'object') {
        if (x instanceof Array) {
            var a = sync9_create_arr()
            sync9_space_dag_add_version(a.S, vid, [[0, 0, x.map(x => sync9_wrap(x, vid))]], _vid => _vid != vid)
            return a
        } else {
            var o = sync9_create_obj()
            Object.entries(x).forEach(([k, v]) => {
                var val = sync9_create_val()
                sync9_space_dag_add_version(val.S, vid, [[0, 0, [sync9_wrap(v, vid)]]], _vid => _vid != vid)
                o.S[k] = val
            })
            return o
        }
    } else throw 'bad'
}


function sync9_create_val() {
    return {
        t : 'val',
        S : sync9_create_space_dag_node('root', [])
    }
}

function sync9_create_obj() {
    return {
        t : 'obj',
        S : {}
    }
}

function sync9_create_arr() {
    return {
        t : 'arr',
        S : sync9_create_space_dag_node('root', [])
    }
}

function sync9_create_str() {
    return {
        t : 'str',
        S : sync9_create_space_dag_node('root', '')
    }
}

function sync9_create_space_dag_node(vid, elems, end_cap) {
    return {
        vid : vid,
        elems : elems,
        deleted_by : {},
        end_cap : end_cap,
        nexts : [],
        next : null
    }
}

function sync9_space_dag_get(S, i, is_anc) {
    var ret = null
    var offset = 0
    sync9_trav_space_dag(S, is_anc ? is_anc : () => true, (node) => {
        if (i - offset < node.elems.length) {
            ret = node.elems[i - offset]
            return false
        }
        offset += node.elems.length
    })
    return ret
}
    
function sync9_space_dag_break_node(node, x, end_cap, new_next) {
    function subseq(x, start, stop) {
        return (x instanceof Array) ?
            x.slice(start, stop) :
            x.substring(start, stop)
    }
    
    var tail = sync9_create_space_dag_node(null, subseq(node.elems, x), node.end_cap)
    Object.assign(tail.deleted_by, node.deleted_by)
    tail.nexts = node.nexts
    tail.next = node.next
    
    node.elems = subseq(node.elems, 0, x)
    node.end_cap = end_cap
    if (end_cap) tail.gash = true
    node.nexts = new_next ? [new_next] : []
    node.next = tail
    
    return tail
}

function sync9_space_dag_add_version(S, vid, splices, is_anc) {
    
    function add_to_nexts(nexts, to) {
        var i = binarySearch(nexts, function (x) {
            if (to.vid < x.vid) return -1
            if (to.vid > x.vid) return 1
            return 0
        })
        nexts.splice(i, 0, to)
    }
    
    var si = 0
    var delete_up_to = 0
    
    var cb = (node, offset, has_nexts, prev, _vid, deleted) => {
        var s = splices[si]
        if (!s) return false
        
        if (deleted) {
            if (s[1] == 0 && s[0] == offset) {
                if (node.elems.length == 0 && !node.end_cap && has_nexts) return
                var new_node = sync9_create_space_dag_node(vid, s[2])
                if (node.elems.length == 0 && !node.end_cap)
                    add_to_nexts(node.nexts, new_node)
                else
                    sync9_space_dag_break_node(node, 0, undefined, new_node)
                si++
            }
            return            
        }
        
        if (s[1] == 0) {
            var d = s[0] - (offset + node.elems.length)
            if (d > 0) return
            if (d == 0 && !node.end_cap && has_nexts) return
            var new_node = sync9_create_space_dag_node(vid, s[2])
            if (d == 0 && !node.end_cap) {
                add_to_nexts(node.nexts, new_node)
            } else {
                sync9_space_dag_break_node(node, s[0] - offset, undefined, new_node)
            }
            si++
            return
        }
        
        if (delete_up_to <= offset) {
            var d = s[0] - (offset + node.elems.length)
            if (d >= 0) return
            delete_up_to = s[0] + s[1]
            
            if (s[2]) {
                var new_node = sync9_create_space_dag_node(vid, s[2])
                if (s[0] == offset && node.gash) {
                    if (!prev.end_cap) throw 'no end_cap?'
                    add_to_nexts(prev.nexts, new_node)
                } else {
                    sync9_space_dag_break_node(node, s[0] - offset, true, new_node)
                    return
                }
            } else {
                if (s[0] == offset) {
                } else {
                    sync9_space_dag_break_node(node, s[0] - offset)
                    return
                }
            }
        }
        
        if (delete_up_to > offset) {
            if (delete_up_to <= offset + node.elems.length) {
                if (delete_up_to < offset + node.elems.length) {
                    sync9_space_dag_break_node(node, delete_up_to - offset)
                }
                si++
            }
            node.deleted_by[vid] = true
            return
        }
    }
    
    var f = is_anc
    var exit_early = {}
    var offset = 0
    function helper(node, prev, vid) {
        var has_nexts = node.nexts.find(next => f(next.vid))
        var deleted = Object.keys(node.deleted_by).some(vid => f(vid))
        if (cb(node, offset, has_nexts, prev, vid, deleted) == false)
            throw exit_early
        if (!deleted) {
            offset += node.elems.length
        }
        for (var next of node.nexts)
            if (f(next.vid)) helper(next, null, next.vid)
        if (node.next) helper(node.next, node, vid)
    }
    try {
        helper(S, null, S.vid)
    } catch (e) {
        if (e != exit_early) throw e
    }
    
}

function sync9_trav_space_dag(S, f, cb, view_deleted, tail_cb) {
    var exit_early = {}
    var offset = 0
    function helper(node, prev, vid) {
        var has_nexts = node.nexts.find(next => f(next.vid))
        if (view_deleted ||
            !Object.keys(node.deleted_by).some(vid => f(vid))) {
            if (cb(node, offset, has_nexts, prev, vid) == false)
                throw exit_early
            offset += node.elems.length
        }
        for (var next of node.nexts)
            if (f(next.vid)) helper(next, null, next.vid)
        if (node.next) helper(node.next, node, vid)
        else if (tail_cb) tail_cb(node)
    }
    try {
        helper(S, null, S.vid)
    } catch (e) {
        if (e != exit_early) throw e
    }
}

function sync9_get_ancestors(x, vids) {
    var ancs = {}
    function mark_ancs(key) {
        if (!ancs[key]) {
            ancs[key] = true
            Object.keys(x.T[key]).forEach(k => mark_ancs(k))
        }
    }
    Object.keys(vids).forEach(k => mark_ancs(k))
    return ancs
}

function sync9_parse_change(change) {
    var ret = { keys : [] }
    
    var re = /\.?([^\.\[ =]+)|\[((\-?\d+)(:\-?\d+)?|'(\\'|[^'])*'|"(\\"|[^"])*")\]|\s*=\s*(.*)/g
    var m
    while (m = re.exec(change)) {
        if (m[1])
            ret.keys.push(m[1])
        else if (m[2] && m[4])
            ret.range = [
                JSON.parse(m[3]),
                JSON.parse(m[4].substr(1))
            ]
        else if (m[2])
            ret.keys.push(JSON.parse(m[2]))
        else if (m[7])
            ret.val = JSON.parse(m[7])
    }
    
    return ret
}

function sync9_diff_ODI(a, b) {
    var offset = 0
    var prev = null
    var ret = []
    var d = diff_main(a, b)
    for (var i = 0; i < d.length; i++) {
        if (d[i][0] == 0) {
            if (prev) ret.push(prev)
            prev = null
            offset += d[i][1].length
        } else if (d[i][0] == 1) {
            if (prev)
                prev[2] += d[i][1]
            else
                prev = [offset, 0, d[i][1]]
        } else {
            if (prev)
                prev[1] += d[i][1].length
            else
                prev = [offset, d[i][1].length, '']
            offset += d[i][1].length
        }
    }
    if (prev) ret.push(prev)
    return ret
}

function sync9_guid() {
    var x = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    var s = []
    for (var i = 0; i < 15; i++)
        s.push(x[Math.floor(Math.random() * x.length)])
    return s.join('')
}

function sync9_create_proxy(x, cb, path) {
    path = path || ''
    var child_path = key => path + '[' + JSON.stringify(key) + ']'
    return new Proxy(x, {
        get : (x, key) => {
            if (['copyWithin', 'reverse', 'sort', 'fill'].includes(key))
                throw 'proxy does not support function: ' + key
            if (key == 'push') return function () {
                var args = Array.from(arguments)
                cb([path + '[' + x.length + ':' + x.length + '] = ' + JSON.stringify(args)])
                return x.push.apply(x, args)
            }
            if (key == 'pop') return function () {
                cb([path + '[' + (x.length - 1) + ':' + x.length + '] = []'])
                return x.pop()
            }
            if (key == 'shift') return function () {
                cb([path + '[0:1] = []'])
                return x.shift()
            }
            if (key == 'unshift') return function () {
                var args = Array.from(arguments)
                cb([path + '[0:0] = ' + JSON.stringify(args)])
                return x.unshift.apply(x, args)
            }
            if (key == 'splice') return function () {
                var args = Array.from(arguments)
                cb([child_path(key) + '[' + args[0] + ':' + (args[0] + args[1]) + '] = ' + JSON.stringify(args.slice(2))])
                return x.splice.apply(x, args)
            }
            
            var y = x[key]
            if (y && typeof(y) == 'object') {
                return sync9_create_proxy(y, cb, child_path(key))
            } else return y
        },
        set : (x, key, val) => {
            if (typeof(val) == 'string' && typeof(x[key]) == 'string') {
                cb(sync9_diff_ODI(x[key], val).map(splice => {
                    return child_path(key) + '[' + splice[0] + ':' + (splice[0] + splice[1]) + '] = ' + JSON.stringify(splice[2])
                }))
            } else {
                if ((x instanceof Array) && key.match(/^\d+$/)) key = +key
                cb([child_path(key) + ' = ' + JSON.stringify(val)])
            }
            x[key] = val
            return true
        }
    })
}

function sync9_prune(x, has_everyone_whos_seen_a_seen_b, has_everyone_whos_seen_a_seen_b_2) {
    var seen_nodes = {}
    var did_something = true
    function rec(x) {
        if (x && typeof(x) == 'object') {
            if (!x.t && x.val) {
                rec(x.val)
            } else if (x.t == 'val') {
                if (sync9_space_dag_prune(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
                rec(sync9_space_dag_get(x.S, 0))
            } else if (x.t == 'obj') {
                Object.values(x.S).forEach(v => rec(v))
            } else if (x.t == 'arr') {
                if (sync9_space_dag_prune(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
                sync9_trav_space_dag(x.S, () => true, node => {
                    node.elems.forEach(e => rec(e))
                })
            } else if (x.t == 'str') {
                if (sync9_space_dag_prune(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
            }
        }
    }
    while (did_something) {
        did_something = false
        rec(x)
    }

    var visited = {}    
    var delete_us = {}
    function f(vid) {
        if (visited[vid]) return
        visited[vid] = true
        Object.keys(x.T[vid]).forEach(pid => {
            if (has_everyone_whos_seen_a_seen_b_2(pid, vid) && !seen_nodes[pid]) {
                delete_us[pid] = true
            }
            f(pid)
        })
    }
    Object.keys(x.leaves).forEach(f)

    var visited = {}
    var forwards = {}
    function g(vid) {
        if (visited[vid]) return
        visited[vid] = true
        if (delete_us[vid])
            forwards[vid] = {}
        Object.keys(x.T[vid]).forEach(pid => {
            g(pid)
            if (delete_us[vid]) {
                if (delete_us[pid])
                    Object.assign(forwards[vid], forwards[pid])
                else
                    forwards[vid][pid] = true
            } else if (delete_us[pid]) {
                delete x.T[vid][pid]
                Object.assign(x.T[vid], forwards[pid])
            }
        })
    }
    Object.keys(x.leaves).forEach(g)
    Object.keys(delete_us).forEach(vid => delete x.T[vid])
    return delete_us
}

function sync9_space_dag_prune(S, has_everyone_whos_seen_a_seen_b, seen_nodes) {
    function set_nnnext(node, next) {
        while (node.next) node = node.next
        node.next = next
    }
    function process_node(node, offset, vid, prev) {
        var nexts = node.nexts
        var next = node.next

        var first_prunable = nexts.findIndex(x => has_everyone_whos_seen_a_seen_b(vid, x.vid))
        if (first_prunable > 0 && (node.elems.length > 0 || !prev)) {
            first_prunable = nexts.findIndex((x, i) => (i > first_prunable) && has_everyone_whos_seen_a_seen_b(vid, x.vid))
        }
        
        if (first_prunable >= 0) {
            var gamma = next
            if (first_prunable + 1 < nexts.length) {
                gamma = sync9_create_space_dag_node(null, typeof(node.elems) == 'string' ? '' : [])
                gamma.nexts = nexts.slice(first_prunable + 1)
                gamma.next = next
            }
            if (first_prunable == 0) {
                if (nexts[0].elems.length == 0 && !nexts[0].end_cap && nexts[0].nexts.length > 0) {
                    var beta = gamma
                    if (nexts[0].next) {
                        beta = nexts[0].next
                        set_nnnext(beta, gamma)
                    }
                    node.nexts = nexts[0].nexts
                    node.next = beta
                } else {
                    delete node.end_cap
                    node.nexts = []
                    node.next = nexts[0]
                    node.next.vid = null
                    set_nnnext(node, gamma)
                }
            } else {
                node.nexts = nexts.slice(0, first_prunable)
                node.next = nexts[first_prunable]
                node.next.vid = null
                set_nnnext(node, gamma)
            }
            return true
        }
        
        if (Object.keys(node.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k))) {
            node.deleted_by = {}
            node.elems = typeof(node.elems) == 'string' ? '' : []
            delete node.gash
            return true
        } else {
            Object.assign(seen_nodes, node.deleted_by)
        }
        
        if (next && !next.nexts[0] && (Object.keys(next.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k)) || next.elems.length == 0)) {
            node.next = next.next
            return true
        }
        
        if (nexts.length == 0 && next &&
            !(next.elems.length == 0 && !next.end_cap && next.nexts.length > 0) &&
            Object.keys(node.deleted_by).every(x => next.deleted_by[x]) &&
            Object.keys(next.deleted_by).every(x => node.deleted_by[x])) {
            node.elems = node.elems.concat(next.elems)
            node.end_cap = next.end_cap
            node.nexts = next.nexts
            node.next = next.next
            return true
        }
    }
    var did_something = false
    sync9_trav_space_dag(S, () => true, (node, offset, has_nexts, prev, vid) => {
        if (!prev) seen_nodes[vid] = true
        while (process_node(node, offset, vid, prev)) {
            did_something = true
        }
    }, true)
    return did_something
}

// modified from https://stackoverflow.com/questions/22697936/binary-search-in-javascript
function binarySearch(ar, compare_fn) {
    var m = 0;
    var n = ar.length - 1;
    while (m <= n) {
        var k = (n + m) >> 1;
        var cmp = compare_fn(ar[k]);
        if (cmp > 0) {
            m = k + 1;
        } else if(cmp < 0) {
            n = k - 1;
        } else {
            return k;
        }
    }
    return m;
}

































var diffsync = (typeof(module) != 'undefined') ? module.exports : {}

diffsync.version = 1039
diffsync.port = 60607

// var client = diffsync.create_client({
//     channel : 'the_cool_room',
//     get_text : function () {
//         return current_text_displayed_to_user
//     },
//     on_text : function (text) {
//         current_text_displayed_to_user = text
//     },
// })
//
// client.on_change() <-- call this when the user changes the text or cursor/selection position
//
diffsync.create_client = function (options, s_funcs) {
    var self = {}
    self.on_change = null

    var on_channels = null

    var uid = guid()
    var minigit = diffsync.create_minigit()
    var unacknowledged_commits = {}

    self.join = function () {
        function send(o) {
            o.v = diffsync.version
            o.uid = uid
            o.channel = options.channel
            s_funcs.send(JSON.stringify(o))
        }
    
        send({ join : true })

        var sent_unacknowledged_commits = false
    
        self.onmessage = function (s) {
            var o = JSON.parse(s)

            if (o.channels) {
                if (on_channels) on_channels(o.channels)
            }
            if (o.commits) {
                self.on_change()
                minigit.merge(o.commits)

                var patch = get_diff_patch(options.get_text(), minigit.cache)
                options.on_text(minigit.cache)

                if (o.welcome) {
                    each(extend(o.commits, minigit.get_ancestors(o.commits)), function (_, id) {
                        delete unacknowledged_commits[id]
                    })
                    if (Object.keys(unacknowledged_commits).length > 0) {
                        send({ commits : unacknowledged_commits })
                    }
                    sent_unacknowledged_commits = true
                }

                send({ leaves : minigit.leaves })
            }
            if (o.may_delete) {
                each(o.may_delete, function (_, id) {
                    delete unacknowledged_commits[id]
                    minigit.remove(id)
                })
            }
        }

        self.on_change = function () {
            if (!connected) { return }

            var old_cache = minigit.cache
            var cs = minigit.commit(options.get_text())
            if (cs) {
                extend(unacknowledged_commits, cs)

                var patch = null
                var c = cs[Object.keys(cs)[0]]
                var parents = Object.keys(c.from_parents)
                if (parents.length == 1)
                    patch = c.from_parents[parents[0]]
                else
                    patch = get_diff_patch(old_cache, minigit.cache)
            }

            if (!sent_unacknowledged_commits) { return }

            if (cs) send({commits: cs})
        }
    }

    return self
}

// options is an object like this: {
//     wss : a websocket server from the 'ws' module,
//     on_change : function (changes) {
//         changes contains commits and members that changed,
//         and looks like: {
//             channel : 'some_channel_name',
//             commits : {...},
//             members : {...}
//         }
//     }
// }
//
diffsync.create_server = function (options, c_funcs) {
    var self = {}
    self.channels = {}

    function new_channel(name) {
        return self.channels[name] = {
            name : name,
            minigit : diffsync.create_minigit(),
            members : {}
        }
    }
    function get_channel(name) {
        return self.channels[name] || new_channel(name)
    }
    
    self.online_users = {}
    
    self.leave = function (id) {
        delete self.online_users[id]
    }

    self.join = function () {
        var uid = null
        var channel_name = null

        self.onmessage = function (message) {
            var o = JSON.parse(message)
            if (o.v != diffsync.version) { return }

            uid = o.uid
            var channel = get_channel(o.channel)
            channel_name = channel.name
            self.online_users[uid] = true
            
            var changes = { channel : channel.name, commits : {}, members : {} }

            if (!channel.members[uid]) channel.members[uid] = { do_not_delete : {}, last_sent : 0 }
            channel.members[uid].last_seen = Date.now()
            changes.members[uid] = channel.members[uid]

            function try_send(uid, message) {
                try {
                    c_funcs.send(uid, message)
                } catch (e) {}
            }
            function send_to_all_but_me(message) {
                each(channel.members, function (_, them) {
                    if (them != uid) {
                        try_send(them, message)
                    }
                })
            }

            if (o.join) {
                try_send(uid, JSON.stringify({ commits : channel.minigit.commits, welcome : true }))
            }
            if (o.commits) {
                var new_commits = {}
                each(o.commits, function (c, id) {
                    if (!channel.minigit.commits[id]) {
                        new_commits[id] = c
                        changes.commits[id] = c
                    }
                })
                channel.minigit.merge(new_commits)

                var new_message = {
                    channel : channel.name,
                    commits : new_commits
                }
                new_message = JSON.stringify(new_message)

                leaves = channel.minigit.get_leaves(new_commits)
                var now = Date.now()
                each(channel.members, function (m, them) {
                    if (them != uid) {
                        if (m.last_seen > m.last_sent) {
                            m.last_sent = now
                            changes.members[them] = m
                        } else if (m.last_sent < now - 3000) {
                            return
                        }
                        extend(m.do_not_delete, leaves)
                        try_send(them, new_message)
                    }
                })
                if (!o.leaves) o.leaves = channel.minigit.get_leaves(o.commits)
            }
            if (o.leaves) {
                extend(channel.members[uid].do_not_delete, o.leaves)
                each(channel.minigit.get_ancestors(o.leaves), function (_, id) {
                    delete channel.members[uid].do_not_delete[id]
                })

                var necessary = {}
                each(channel.members, function (m) {
                    extend(necessary, m.do_not_delete)
                })

                var affected = channel.minigit.remove_unnecessary(necessary)
                extend(changes.commits, affected)

                var new_message = {
                    channel : channel.name,
                    may_delete : {}
                }
                each(affected, function (c, id) {
                    if (c.delete_me) {
                        new_message.may_delete[id] = true
                    }
                })
                if (Object.keys(new_message.may_delete).length > 0) {
                    new_message = JSON.stringify(new_message)
                    each(channel.members, function (m, them) {
                        try_send(them, new_message)
                    })
                }
            }

            if (options.on_change) options.on_change(changes)
        }
    }

    return self
}

///////////////

diffsync.create_minigit = function () {
    var self = {
        commits : {},
        to_children : {},
        commit_cache : {},
        leaves : {},
        cache : ''
    }

    self.remove_unnecessary = function (spare_us) {
        var affected = {}
        while (true) {
            var found = false
            each(self.commits, function (c, id) {
                if (spare_us[id]) { return }
                var aff = self.remove(id)
                if (aff) {
                    extend(affected, aff)
                    found = true
                }
            })
            if (!found) break
        }
        return affected
    }

    self.remove = function (id) {
        var keys = Object.keys(self.to_children[id])
        if (keys.length == 1) {
            var affected = {}

            var being_removed = self.commits[id]
            var c_id = keys[0]
            var c = self.commits[c_id]

            self.get_text(c_id)
            each(being_removed.to_parents, function (_, id) {
                self.get_text(id)
            })

            delete self.commits[id]
            delete self.commit_cache[id]
            delete c.to_parents[id]
            delete c.from_parents[id]
            being_removed.delete_me = true
            affected[id] = being_removed

            each(being_removed.to_parents, function (_, id) {
                var x = get_diff_patch_2(self.get_text(c_id), self.get_text(id))
                c.to_parents[id] = x[0]
                c.from_parents[id] = x[1]
            })
            if (Object.keys(c.to_parents).length == 0) {
                c.text = self.get_text(c_id)
            }
            affected[c_id] = c

            self.calc_children()

            return affected
        }
    }

    self.commit = function (s) {
        if (s == self.cache) { return }

        var c = {
            to_parents : {},
            from_parents : {}
        }
        if (Object.keys(self.leaves).length == 0) {
            c.text = s
        } else {
            each(self.leaves, function (_, leaf) {
                var x = get_diff_patch_2(s, self.get_text(leaf))
                c.to_parents[leaf] = x[0]
                c.from_parents[leaf] = x[1]
            })
        }

        var id = guid()
        self.commits[id] = c
        self.calc_children()
        self.leaves = {}
        self.leaves[id] = true
        self.commit_cache[id] = s
        self.cache = s
        self.purge_cache()

        var cs = {}
        cs[id] = c
        return cs
    }

    self.merge = function (cs) {
        each(cs, function (c, id) {
            if (!self.commits[id]) {
                self.commits[id] = c
            } else {
                if (c.text) self.commits[id].text = c.text
                extend(self.commits[id].to_parents, c.to_parents)
                extend(self.commits[id].from_parents, c.from_parents)
            }
        })
        self.calc_children()
        self.leaves = self.get_leaves()
        self.cache = self.rec_merge(self.leaves)
        self.purge_cache()
        return self.cache
    }

    self.calc_children = function () {
        self.to_children = {}
        each(self.commits, function (c, id) {
            self.to_children[id] = {}
        })
        each(self.commits, function (c, id) {
            each(c.from_parents, function (d, p_id) {
                self.to_children[p_id][id] = d
            })
        })
    }

    self.purge_cache = function () {
        each(self.commits, function (c, id) {
            if (Object.keys(c.to_parents).length > 0 && !self.leaves[id]) {
                delete self.commit_cache[id]
            }
        })
    }

    self.get_text = function (id) {
        if (self.commit_cache[id] != null) return self.commit_cache[id]

        var frontier = [id]
        var back_pointers = {}
        back_pointers[id] = id
        while (true) {
            var next = frontier.shift()

            if (!next) { throw 'data structure corrupted' }
            var c_id = next
            var c = self.commits[c_id]
            var text = (c.text != null) ? c.text : self.commit_cache[c_id]
            if (text != null) {
                var snowball = text
                while (true) {
                    if (next == id) {
                        return self.commit_cache[id] = snowball
                    }
                    next = back_pointers[next]
                    snowball = apply_diff_patch(snowball, c.to_parents[next] || self.to_children[c_id][next])
                    c_id = next
                    c = self.commits[c_id]
                }
            }

            each(c.to_parents, function (_, id) {
                if (!back_pointers[id]) {
                    back_pointers[id] = next
                    frontier.push(id)
                }
            })
            each(self.to_children[c_id], function (_, id) {
                if (!back_pointers[id]) {
                    back_pointers[id] = next
                    frontier.push(id)
                }
            })
        }
    }

    self.rec_merge = function (these) {
        these = Object.keys(these)
        if (these.length == 0) { return '' }
        var r = self.get_text(these[0])
        if (these.length == 1) { return r }
        var r_ancestors = self.get_ancestors(these[0])
        for (var i = 1; i < these.length; i++) {
            var i_ancestors = self.get_ancestors(these[i])
            var o = self.rec_merge(self.get_leaves(intersection(r_ancestors, i_ancestors)))
            r = apply_diff_patch(o, get_merged_diff_patch(r, self.get_text(these[i]), o))
            extend(r_ancestors, i_ancestors)
        }
        return r
    }

    self.get_leaves = function (commits) {
        if (!commits) commits = self.commits
        var leaves = {}
        each(commits, function (_, id) { leaves[id] = true })
        each(commits, function (c) {
            each(c.to_parents, function (_, p) {
                delete leaves[p]
            })
        })
        return leaves
    }

    self.get_ancestors = function (id_or_set) {
        var frontier = null
        if (typeof(id_or_set) == 'object') {
            frontier = Object.keys(id_or_set)
        } else {
            frontier = [id_or_set]
        }
        var ancestors = {}
        while (frontier.length > 0) {
            var next = frontier.shift()
            each(self.commits[next].to_parents, function (_, p) {
                if (!ancestors[p]) {
                    ancestors[p] = self.commits[p]
                    frontier.push(p)
                }
            })
        }
        return ancestors
    }

    return self
}

///////////////

function guid() {
    var x = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    var s = []
    for (var i = 0; i < 15; i++) {
        s.push(x[Math.floor(Math.random() * x.length)])
    }
    return s.join('')
}

function each(o, cb) {
    if (o instanceof Array) {
        for (var i = 0; i < o.length; i++) {
            if (cb(o[i], i, o) == false)
                return false
        }
    } else {
        for (var k in o) {
            if (o.hasOwnProperty(k)) {
                if (cb(o[k], k, o) == false)
                    return false
            }
        }
    }
    return true
}

function map_array(a, f) {
    var b = []
    each(a, function (v, k) { b[k] = f(v) })
    return b
}

function extend(a, b) {
    each(b, function (x, key) { a[key] = x })
    return a
}

function intersection(a, b) {
    var common = {}
    each(a, function (_, x) {
        if (b[x]) {
            common[x] = a[x]
        }
    })
    return common
}

///////////////

var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

function get_merged_diff_patch(a, b, o) {
    var a_diff = get_diff_patch(o, a)
    var b_diff = get_diff_patch(o, b)
    var ds = []
    var prev_d = null
    while (a_diff.length > 0 || b_diff.length > 0) {
        var d = a_diff.length == 0 ?
            b_diff.shift() :
            b_diff.length == 0 ?
                a_diff.shift() :
                a_diff[0][0] < b_diff[0][0] ?
                    a_diff.shift() :
                    a_diff[0][0] > b_diff[0][0] ?
                        b_diff.shift() :
                        a_diff[0][2] < b_diff[0][2] ?
                            a_diff.shift() :
                            b_diff.shift()
        if (prev_d && d[0] < prev_d[0] + prev_d[1]) {
            if (d[0] + d[1] > prev_d[0] + prev_d[1]) {
                prev_d[1] = d[0] + d[1] - prev_d[0]
            }
            prev_d[2] += d[2]
        } else {
            ds.push(d)
            prev_d = d
        }
    }
    return ds
}

function apply_diff_patch(s, diff) {
    var offset = 0
    for (var i = 0; i < diff.length; i++) {
        var d = diff[i]
        s = s.slice(0, d[0] + offset) + d[2] + s.slice(d[0] + offset + d[1])
        offset += d[2].length - d[1]
    }
    return s
}

function diff_convert_to_my_format(d, factor) {
    if (factor === undefined) factor = 1
    var x = []
    var ii = 0
    for (var i = 0; i < d.length; i++) {
        var dd = d[i]
        if (dd[0] == DIFF_EQUAL) {
            ii += dd[1].length
            continue
        }
        var xx = [ii, 0, '']
        if (dd[0] == DIFF_INSERT * factor) {
            xx[2] = dd[1]
        } else if (dd[0] == DIFF_DELETE * factor) {
            xx[1] = dd[1].length
            ii += xx[1]
        }
        if (i + 1 < d.length) {
            dd = d[i + 1]
            if (dd[0] != DIFF_EQUAL) {
                if (dd[0] == DIFF_INSERT * factor) {
                    xx[2] = dd[1]
                } else if (dd[0] == DIFF_DELETE * factor) {
                    xx[1] = dd[1].length
                    ii += xx[1]
                }
                i++
            }
        }
        x.push(xx)
    }
    return x
}

function get_diff_patch(a, b) {
    return diff_convert_to_my_format(diff_main(a, b))
}

function get_diff_patch_2(a, b) {
    var x = diff_main(a, b)
    return [diff_convert_to_my_format(x),
        diff_convert_to_my_format(x, -1)]
}

diffsync.get_diff_patch = get_diff_patch
diffsync.get_diff_patch_2 = get_diff_patch_2

/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {Int} cursor_pos Expected edit position in text1 (optional)
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1, text2, cursor_pos) {
  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  // Check cursor_pos within bounds
  if (cursor_pos < 0 || text1.length < cursor_pos) {
    cursor_pos = null;
  }

  // Trim off common prefix (speedup).
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = diff_compute_(text1, text2);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs);
  if (cursor_pos != null) {
    diffs = fix_cursor(diffs, cursor_pos);
  }
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1, text2) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  return diff_bisect_(text1, text2);
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);

  return diffs.concat(diffsb);
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = diff_commonPrefix(longtext.substring(i),
                                           shorttext.substring(j));
      var suffixLength = diff_commonSuffix(longtext.substring(0, i),
                                           shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 */
function diff_cleanupMerge(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs);
  }
};


/*
 * Modify a diff such that the cursor position points to the start of a change:
 * E.g.
 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
 */
function cursor_normalize_diff (diffs, cursor_pos) {
  if (cursor_pos === 0) {
    return [DIFF_EQUAL, diffs];
  }
  for (var current_pos = 0, i = 0; i < diffs.length; i++) {
    var d = diffs[i];
    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
      var next_pos = current_pos + d[1].length;
      if (cursor_pos === next_pos) {
        return [i + 1, diffs];
      } else if (cursor_pos < next_pos) {
        // copy to prevent side effects
        diffs = diffs.slice();
        // split d into two diff changes
        var split_pos = cursor_pos - current_pos;
        var d_left = [d[0], d[1].slice(0, split_pos)];
        var d_right = [d[0], d[1].slice(split_pos)];
        diffs.splice(i, 1, d_left, d_right);
        return [i + 1, diffs];
      } else {
        current_pos = next_pos;
      }
    }
  }
  throw new Error('cursor_pos is out of bounds!')
}

/*
 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
 *
 * Case 1)
 *   Check if a naive shift is possible:
 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
 * Case 2)
 *   Check if the following shifts are possible:
 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
 *         ^            ^
 *         d          d_next
 *
 * @param {Array} diffs Array of diff tuples
 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
 * @return {Array} Array of diff tuples
 */
function fix_cursor (diffs, cursor_pos) {
  var norm = cursor_normalize_diff(diffs, cursor_pos);
  var ndiffs = norm[1];
  var cursor_pointer = norm[0];
  var d = ndiffs[cursor_pointer];
  var d_next = ndiffs[cursor_pointer + 1];

  if (d == null) {
    // Text was deleted from end of original string,
    // cursor is now out of bounds in new string
    return diffs;
  } else if (d[0] !== DIFF_EQUAL) {
    // A modification happened at the cursor location.
    // This is the expected outcome, so we can return the original diff.
    return diffs;
  } else {
    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
      // Case 1)
      // It is possible to perform a naive shift
      ndiffs.splice(cursor_pointer, 2, d_next, d)
      return merge_tuples(ndiffs, cursor_pointer, 2)
    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
      // Case 2)
      // d[1] is a prefix of d_next[1]
      // We can assume that d_next[0] !== 0, since d[0] === 0
      // Shift edit locations..
      ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
      var suffix = d_next[1].slice(d[1].length);
      if (suffix.length > 0) {
        ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
      }
      return merge_tuples(ndiffs, cursor_pointer, 3)
    } else {
      // Not possible to perform any modification
      return diffs;
    }
  }

}

/*
 * Try to merge tuples with their neigbors in a given range.
 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
 *
 * @param {Array} diffs Array of diff tuples.
 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
 * @param {Int} length Number of consecutive elements to check.
 * @return {Array} Array of merged diff tuples.
 */
function merge_tuples (diffs, start, length) {
  // Check from (start-1) to (start+length).
  for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
    if (i + 1 < diffs.length) {
      var left_d = diffs[i];
      var right_d = diffs[i+1];
      if (left_d[0] === right_d[1]) {
        diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
      }
    }
  }
  return diffs;
}















main()









</script>
