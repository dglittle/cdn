
<script src="https://dglittle.github.io/cdn/random002.js"></script>
<script src="https://invisible-college.github.io/universal-sync/diffsync.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sjcl/1.0.8/sjcl.min.js"></script>

<body style="margin:0px"></body>
<script>

var tau = Math.PI*2

function main() {
    var rand = create_rand('000_hi_001')
    
    var n_peers = 4
    
    var debug_frames = []

    var peers = {}
    for (var i = 0; i < n_peers; i++) {
        ;(() => {
            var p = create_node()
            ;[['get', 2], ['set', 2], ['multiset', 5], ['ack', 3], ['disconnected', 4]].forEach(x => {
                var [key, t_index] = x
                p['on_' + key] = function () {
                    var args = [...arguments].map(x => (x != null) ? JSON.parse(JSON.stringify(x)) : null)
                    var t = args[t_index]
                    if ((key != 'get') && !p.keys.my_key.conns[t.conn.id]) throw 'you cannot talk to them!'
                    peers[t.conn.pid].incoming.push([p.pid, () => {
                        var to_pid = t.conn.pid
                        t.conn = {id: t.conn.id, pid: p.pid}
                        peers[to_pid][key](...args)
                    }, 'msg_id:' + sync9_guid(), key, args[2]])
                }
            })
            
            p.pid = 'P' + (i + 1)
            
            p.incoming = []
            peers[p.pid] = p
            
            p.connect = (pid, alpha) => {
                if (alpha) {
                    p.on_get('my_key', true, {conn: {id: sync9_guid(), pid}})
                }
            }
            
            if (i == 0) {
                p.letters = 'abcdefghijklmnopqrstuvwxyz'
                for (var ii = 0; ii < 100; ii++) {
                    p.letters += String.fromCharCode(12032 + ii)
                }
                p.letters_i = 0
            } else if (i == 1) {
                p.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                for (var ii = 0; ii < 100; ii++) {
                    p.letters += String.fromCharCode(12032 + 1000 + ii)
                }
                p.letters_i = 0
            } else {
                p.letters = ''
                for (var ii = 0; ii < 100; ii++) {
                    p.letters += String.fromCharCode(12032 + 1000*i + ii)
                }
                p.letters_i = 0
            }
        })()
    }
    var peers_array = Object.values(peers)
    

    for (var p1 = 0; p1 < n_peers; p1++) {
        for (var p2 = p1 + 1; p2 < n_peers; p2++) {
            notes = ['connecting ' + p1 + ':' + peers_array[p1].pid + ' and ' + p2 + ':' + peers_array[p2].pid]
            
            var alpha = rand() < 0.5
            peers_array[p1].connect(peers_array[p2].pid, alpha)
            peers_array[p2].connect(peers_array[p1].pid, !alpha)
            
            if (debug_frames) debug_frames.push({
                peers: peers_array.map(x => JSON.parse(JSON.stringify(x)))
            })
        }
    }
    
    if (true) {
        let p = peers_array[0]
        p.set('my_key', ['=""'], {version: 'root', parents: {}})
        if (debug_frames) debug_frames.push({
            peers: peers_array.map(x => JSON.parse(JSON.stringify(x)))
        })
    }
    
    function step(frame_num) {
        var i = Math.floor(rand() * n_peers)
        var p = peers_array[i]
        
        if (rand() < 0.05) {
            if (rand() < 0.9) {
                if (p.keys['my_key'] && Object.keys(p.keys['my_key'].s9.T).length) {
                    if (p.letters_i >= p.letters.length) {
                        p.letters_i = 0
                    }
                    var e = create_random_edit(p.keys['my_key'].s9, p.letters[p.letters_i++])
                    p.set('my_key', e.changes, {version: e.vid, parents: e.parents})
                }
            } else {
                var other_p = p
                while (other_p == p) {
                    other_p = peers_array[Math.floor(rand() * n_peers)]
                }
                var disconnect = false
                Object.values(p.keys.my_key ? p.keys.my_key.conns : []).forEach(c => {
                    if (c.pid == other_p.pid) {
                        disconnect = true
                        p.disconnected('my_key', null, null, null, {conn: c})
                    }
                })
                Object.values(other_p.keys.my_key ? other_p.keys.my_key.conns : []).forEach(c => {
                    if (c.pid == p.pid) {
                        disconnect = true
                        other_p.disconnected('my_key', null, null, null, {conn: c})
                    }
                })
                if (disconnect) {
                    p.incoming = p.incoming.filter(x => x[0] != other_p.pid)
                    other_p.incoming = other_p.incoming.filter(x => x[0] != p.pid)
                } else {
                    var alpha = rand() < 0.5
                    p.connect(other_p.pid, alpha)
                    other_p.connect(p.pid, !alpha)
                }
            }
        } else {
            var did_something = false
            if (p.incoming.length > 0) {
                did_something = true
                
                var possible_peers = {}
                p.incoming.forEach(x => possible_peers[x[0]] = true)
                possible_peers = Object.keys(possible_peers)
                var chosen_peer = possible_peers[Math.floor(rand() * possible_peers.length)]
                
                var msg = p.incoming.splice(p.incoming.findIndex(x => x[0] == chosen_peer), 1)[0][1]()
            }
        }
        
        debug_frames.push({
            frame_num,
            peers: peers_array.map(x => JSON.parse(JSON.stringify(x)))
        })
    }

    function create_random_edit(s9, letters) {
        letters = letters || 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        var str = sync9_read(s9)
        var start = Math.floor(rand() * (str.length + 1))
        var del = Math.floor(rand() * rand() * (str.length - start + 1))
        var ins = letters[Math.floor(rand() * letters.length)].repeat(Math.floor(rand() * 4) + (del == 0 ? 1 : 0))
        
        s9.next_version_id = (s9.next_version_id || 0) + 1
        var vid = letters + s9.next_version_id
        
        var changes = [`[${start}:${start + del}] = ` + JSON.stringify(ins)]
        
        return {
            vid : vid,
            parents : Object.assign({}, s9.leaves),
            changes : changes
        }
    }
    
    function draw_frame(di) {
        if (di == null) di = debug_frames.length - 1
        var d = debug_frames[di]
        
        g.clearRect(0, 0, c.width, c.height)
        
        draw_network(c, g, debug_frames, di, 0, 0, 800, 800, 300)
        peers_array.forEach((p, i) => {
            p = d.peers[i]
            var x = 800
            var y = 20 + 450*i
            var r = 10
            if (p.keys.my_key) {
                draw_fissure_dag(c, g, debug_frames, di, i, x, y, 100, 300, r)
                
                draw_time_dag(c, g, debug_frames, di, i, x + 100, y, 300, 300, r)
                
                var v = p.keys.my_key.s9.val
                var S = null
                
                if (v && v.t == 'val') v = sync9_space_dag_get(v.S, 0)
                if (v && v.t == 'lit') v = v.S
                if (typeof(v) == 'string') S = sync9_create_space_dag_node(null, v)
                if (v && v.t == 'str') S = v.S
                if (S) draw_space_dag(p, g, S, x + 400, y)
            }
        })
        
        draw_text(c, g, 'f# = ' + d.frame_num, 0, 0, 'grey', 'left', 'top')
        
        
        // top_part.innerHTML = ''
        // top_part.style.display = 'grid'
        // top_part.style['grid-template-columns'] = '1fr 1fr 1fr'
        // peers_array.forEach((p, i) => {
        //     p = d.peers[i]
        //     var dd = document.createElement('textarea')
        //     dd.value = '= ' + (p.keys.my_key ? JSON.stringify(sync9_read(p.keys.my_key.s9)) : 'n/a') + '\n\n' + JSON.stringify(p, null, '    ')
        //     top_part.append(dd)
        // })        
    }
    
    var a = document.createElement('div')
    a.style.display = 'grid'
    a.style['grid-template-rows'] = '1fr 20px'
    a.style.width = '100%'
    a.style.height = '100%'
    document.body.append(a)
    
    var c = document.createElement('canvas')
    c.width = 1000 * devicePixelRatio
    c.height = (window.innerHeight - 20) * devicePixelRatio
    c.style.width = (c.width / devicePixelRatio) + 'px'
    c.style.height = (c.height / devicePixelRatio) + 'px'
    var g = c.getContext('2d')
    a.append(c)
    
    // var top_part = document.createElement('div')
    // a.append(top_part)
    
    var slider = document.createElement('input')
    slider.style.width = '50%'
    slider.setAttribute('type', 'range')
    slider.setAttribute('min', '0')
    slider.setAttribute('max', debug_frames.length - 1)
    slider.setAttribute('value', debug_frames.length - 1)
    slider.oninput = () => {
        is_on = false
        draw_frame(1*slider.value)
    }
    a.append(slider)

    draw_frame()
    
    var loop_count = 0
    
    var is_on = false
    loop()
    function loop() {
        if (is_on) {
            try {
                step(loop_count)
            } catch (e) {
                console.log('error on loop_count = ' + loop_count)
                throw 'stop'
            }
            draw_frame()
            if (debug_frames.length > 300) debug_frames = debug_frames.slice(100)
            slider.setAttribute('max', debug_frames.length - 1)
            slider.value = debug_frames.length - 1
            
            loop_count++
        }
        setTimeout(loop, 30)
    }
    
    c.addEventListener('mousedown', () => {
        is_on = !is_on
    })
}

function draw_text(c, g, text, x, y, color, x_align, y_align, font) {
    g.font = font || '15px Arial'
    if (color) g.fillStyle = color
    g.textAlign = x_align || 'left'
    g.textBaseline = y_align || 'middle'
    g.fillText(text, x, y)
}

function draw_network(c, g, frames, fi, x, y, w, h, r) {
    var peers = frames[fi].peers
    
    g.beginPath()
    g.lineWidth = 0.5
    g.strokeStyle = 'red'
    g.rect(x, y, w, h)
    g.stroke()
    g.beginPath()
    g.arc(x + w/2, y + h/2, r, 0, tau)
    g.stroke()
    
    for (var i = 0; i < peers.length; i++) {
        for (var ii = i + 1; ii < peers.length; ii++) {
            var a = tau / peers.length * i
            var aa = tau / peers.length * ii
            
            var p = peers[i]
            var other_p = peers[ii]
            
            var connected = Object.values(p.keys.my_key ? p.keys.my_key.conns : {}).some(c => c.pid == other_p.pid) || Object.values(other_p.keys.my_key ? other_p.keys.my_key.conns : {}).some(c => c.pid == p.pid) || p.incoming.some(x => x[0] == other_p.pid) || other_p.incoming.some(x => x[0] == p.pid)

            if (connected) {
                g.beginPath()
                g.strokeStyle = 'darkgrey'
                g.lineWidth = w/30
                g.moveTo(x + w/2 + Math.cos(a)*r, y + h/2 + Math.sin(a)*r)
                g.lineTo(x + w/2 + Math.cos(aa)*r, y + h/2 + Math.sin(aa)*r)
                g.stroke()
            }
            
            
            
            function func(i, ii, m, a, aa) {
                if (m[0] != peers[ii].pid) return
                
                var before_frame = fi
                while ((before_frame >= 0) && frames[before_frame].peers[i].incoming.some(mm => mm[2] == m[2])) before_frame--
                
                var after_frame = fi
                while ((after_frame < frames.length) && frames[after_frame].peers[i].incoming.some(mm => mm[2] == m[2])) after_frame++
                
                g.beginPath()
                g.strokeStyle = 'purple'
                
                var f = lerp(before_frame, 0, after_frame, 1, fi)
                var p1 = [x + w/2 + Math.cos(a)*r, y + h/2 + Math.sin(a)*r]
                var p2 = [x + w/2 + Math.cos(aa)*r, y + h/2 + Math.sin(aa)*r]
                var pos = lerp(0, p1, 1, p2, f)
                
                
                
                if (m[3] == 'get') {
                    g.save()
                    g.translate(pos[0], pos[1])
                    g.rotate(Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) + tau/4)
                    
                    draw_text(c, g, 'G', 0, 0, 'white', 'center', 'middle')
                    
                    g.restore()
                                        
                    
                    g.beginPath()
                    g.moveTo(pos[0], pos[1])
                    var rot_by = tau/12*5
                    var t1 = add(pos, mul(rot(norm(sub(p2, pos)), rot_by), w/30))
                    var t2 = add(pos, mul(rot(norm(sub(p2, pos)), -rot_by), w/30))
                    g.lineTo(t1[0], t1[1])
                    g.lineTo(t2[0], t2[1])
                    g.lineWidth = 1
                    g.strokeStyle = 'white'
                    g.stroke()
                    
                    
                } else {
                
                    g.beginPath()
                    
                    g.moveTo(pos[0], pos[1])
    
                    // work here
                    var rot_by = tau/12*5
                    var t1 = add(pos, mul(rot(norm(sub(p2, pos)), rot_by), w/30))
                    var t2 = add(pos, mul(rot(norm(sub(p2, pos)), -rot_by), w/30))
                    
                    g.lineTo(t1[0], t1[1])
                    g.lineTo(t2[0], t2[1])
                    
                    g.closePath()
                    
                    
                    g.fillStyle = m[3] == 'get' ? 'green' :
                        m[3] == 'set' ? 'red' :
                        m[3] == 'multiset' ? 'brown' :
                        (m[3] == 'ack' && m[4] == 'local') ? 'skyblue' :
                        (m[3] == 'ack' && m[4] == 'global') ? 'royalblue' : 'magenta'
                    
                    g.fill()
                }
            }
            
            peers[i].incoming.forEach(m => func(i, ii, m, aa, a))
            peers[ii].incoming.forEach(m => func(ii, i, m, a, aa))
        }
    }
    
    peers.forEach((p, i) => {
        var a = tau / peers.length * i
        g.beginPath()
        g.fillStyle = p.incoming.length > 0 ? 'blue' : 'green'
        var pos = [
            x + w/2 + Math.cos(a)*r,
            y + h/2 + Math.sin(a)*r
        ]
        g.arc(pos[0], pos[1], w/30, 0, tau)
        g.fill()
    })
}

function draw_fissure_dag(c, g, frames, fi, pi, x, y, w, h, r) {
    var peers = frames[fi].peers
    var peer = peers[pi].keys.my_key
    if (!peer) return
    
    var fs = {}
    Object.values(peer.fissures).forEach(f => {
        var ff = fs[f.conn]
        if (!ff) {
            var rand = create_rand(f.conn)
            ff = fs[f.conn] = {
                id: f.conn,
                color: '#' + rand().toString(16).slice(2, 8),
                radius: r * (1 + rand()),
                parents: {}
            }
        }
        if (f.a < f.b) ff.has_side_a = true
        if (f.b < f.a) ff.has_side_b = true
        
        Object.keys(f.parents).forEach(p => {
            
            // work here
            if (!peer.fissures[p]) {
                //debugger
                
                ff.has_issue = true
                
                return
            }
            
            ff.parents[peer.fissures[p].conn] = true
        })
    })
    
    function get_layer(k) {
        if (fs[k].layer) return fs[k].layer
        return fs[k].layer = Object.keys(fs[k].parents).reduce((x, p) => {
            return Math.max(x, get_layer(p) + 1)
        }, 0)
    }
    Object.keys(fs).forEach(get_layer)
    
    var layer_members = {}
    var num_layers = 0
    Object.values(fs).forEach(f => {
        layer_members[f.layer] = layer_members[f.layer] || []
        layer_members[f.layer].push(f.id)
        
        if (f.layer >= num_layers) num_layers = f.layer + 1
    })
    
    Object.values(layer_members).forEach(layer => {
        layer.sort().forEach((k, i) => {
            fs[k].layer_i = i
        })
    })

    function get_node_pos(f) {
        var layer_count = layer_members[f.layer].length
        return [
            lerp(0, x + r, layer_count, x + w - r, f.layer_i + 0.5),
            y + r + (f.layer * r*4)
        ]
    }

    Object.values(fs).forEach(f => {
        var a = get_node_pos(f)
        g.beginPath()
        Object.keys(f.parents).map(x => fs[x]).forEach(p => {
            var b = get_node_pos(p)
            g.moveTo(a[0], a[1])
            g.lineTo(b[0], b[1])
        })
        g.lineWidth = 3
        g.strokeStyle = 'lightblue'
        g.stroke()
    })
    
    Object.values(fs).forEach(f => {
        var node_pos = get_node_pos(f)
        
        var rand = create_rand(f.id)
        var color = '#' + rand().toString(16).slice(2, 8)
        var rr = r * (1 + rand())
        
        g.beginPath()
        g.arc(node_pos[0], node_pos[1], rr, 0, tau)
        g.fillStyle = f.has_issue ? 'red' : 'white'
        g.fill()
        
        g.beginPath()
        if (f.has_side_a) {
            g.arc(node_pos[0], node_pos[1], rr, tau/4, tau*3/4)
        }
        if (f.has_side_b) {
            g.arc(node_pos[0], node_pos[1], rr, tau*3/4, tau/4)
        }
        g.strokeStyle = color
        g.lineWidth = 2
        g.stroke()
    })
}

function draw_time_dag(c, g, frames, fi, pi, x, y, w, h, r) {
    var peers = frames[fi].peers
    var peer = peers[pi].keys.my_key
    if (!peer) return
    var s9 = peer.s9
    
    g.lineWidth = 3
    
    var vs = {}
    function get_layer(v) {
        if (!vs[v]) vs[v] = {vid: v}
        if (vs[v].layer) return vs[v].layer
        return vs[v].layer = Object.keys(s9.T[v]).reduce((x, p) => {
            return Math.max(x, get_layer(p) + 1)
        }, 0)
    }
    Object.keys(s9.T).forEach(get_layer)
    
    var layer_members = {}
    var num_layers = 0
    Object.values(vs).forEach(v => {
        layer_members[v.layer] = layer_members[v.layer] || []
        layer_members[v.layer].push(v.vid)
        
        if (v.layer >= num_layers) num_layers = v.layer + 1
    })
    
    Object.values(layer_members).forEach(layer => {
        layer.sort().forEach((v, i) => {
            vs[v].layer_i = i
        })
    })

    function get_node_pos(v) {
        var layer_count = layer_members[v.layer].length
        return [
            lerp(0, x + r, layer_count + 1, x + w - r, v.layer_i + 1),
            y + r + (v.layer * r*3)
        ]
    }

    Object.entries(vs).forEach(e => {
        var a_pos = get_node_pos(e[1])
        g.beginPath()
        Object.keys(s9.T[e[0]]).forEach(p => {
            g.moveTo(a_pos[0], a_pos[1])
            
            var b_pos = get_node_pos(vs[p])
            g.lineTo(b_pos[0], b_pos[1])
        })
        g.strokeStyle = 'lightblue'
        g.stroke()
    })
    
    var fully_acked = {}
    function mark_fully_acked_rec(v) {
        if (!fully_acked[v]) {
            fully_acked[v] = true
            Object.keys(peer.s9.T[v]).forEach(mark_fully_acked_rec)
        }
    }
    Object.keys(peer.ack_leaves).forEach(mark_fully_acked_rec)
    
    Object.entries(vs).forEach(e => {
        var node_pos = get_node_pos(e[1])
        
        g.beginPath()
        g.arc(node_pos[0], node_pos[1], r, 0, tau)
        g.fillStyle = 'white'
        g.fill()
        
        if (peer.phase_one[e[0]]) {
            var current_count = Math.max(0, peer.phase_one[e[0]].count)
            var max_count = 0
            var search_i = fi
            try {
                let x = null
                while (x = frames[search_i].peers[pi].keys.my_key.phase_one[e[0]]) {
                    max_count = x.count
                    search_i--
                }
            } catch (e) {}
            
            var percent_done = (max_count - current_count) / max_count
            if (percent_done > 0) {
                g.beginPath()
                g.arc(node_pos[0], node_pos[1], r, 0, tau/2, true)
                if (percent_done == 1) {
                    g.arc(node_pos[0], node_pos[1], r, tau/2, 0, true)
                } else if (percent_done < 0.5) {
                    var x = lerp(0, r, 0.5, 0, percent_done)
                    var C = (r*r - x*x) / (2*x)
                    var angle = Math.atan2(r, C)
                    g.arc(node_pos[0], node_pos[1] + C, C + x, tau*3/4 - angle, tau*3/4 + angle)
                } else if (percent_done > 0.5) {
                    var x = lerp(0.5, 0, 1, r, percent_done)
                    var C = (r*r - x*x) / (2*x)
                    var angle = Math.atan2(r, C)
                    g.arc(node_pos[0], node_pos[1] - C, C + x, tau/4 - angle, tau/4 + angle)
                } else {
                    g.arc(node_pos[0], node_pos[1] + C, C + x, 0, tau)
                }
                g.fillStyle = 'lightblue'
                g.fill()
            }
        }
        
        g.beginPath()
        g.arc(node_pos[0], node_pos[1], r, 0, tau)
        if (fully_acked[e[0]]) {
            g.fillStyle = 'blue'
            g.fill()
        } else {
            g.strokeStyle = 'blue'
            g.stroke()
        }
        
        draw_text(c, g, e[0].slice(0, 3), node_pos[0] + r, node_pos[1] + r, 'grey', 'center', 'middle')
    })
    
    Object.keys(peer.conn_leaves).forEach(v => {
        g.beginPath()
        g.fillStyle = 'white'
        var node_pos = get_node_pos(vs[v])
        g.arc(node_pos[0], node_pos[1], r * 0.5, 0, Math.PI*2)
        g.fill()
    })
    
    Object.values(peer.fissures).forEach(f => {
        Object.keys(f.nodes).forEach(v => {
            if (!s9.T[v]) return
            g.beginPath()
            
            var rand = create_rand(f.conn)
            g.strokeStyle = '#' + rand().toString(16).slice(2, 8)
            
            var node_pos = get_node_pos(vs[v])
            //var rr = r * 1.45
            var rr = r * (1 + rand())
            
            g.lineWidth = 2
            if (f.a < f.b) {
                


                // work here
                g.arc(node_pos[0], node_pos[1], rr, tau/4, tau*3/4)
                
                
                
                // g.moveTo(node_pos[0] - rr, node_pos[1] - rr)
                // g.lineTo(node_pos[0] + rr, node_pos[1] - rr)
                // g.lineTo(node_pos[0] + rr, node_pos[1] + rr)
                // g.lineTo(node_pos[0] - rr, node_pos[1] + rr)
            } else {
                
                g.arc(node_pos[0], node_pos[1], rr, tau/4, tau*3/4, true)
                
                
                // var rrr = Math.sqrt(2) * rr
                // g.moveTo(node_pos[0] - rrr, node_pos[1])
                // g.lineTo(node_pos[0], node_pos[1] - rrr)
                // g.lineTo(node_pos[0] + rrr, node_pos[1])
                // g.lineTo(node_pos[0], node_pos[1] + rrr)
                // g.closePath()
            }
            g.stroke()
        })
    })
    
}

function draw_space_dag(c, g, S, x, y) {
    function helper(node, y, px, py) {
        g.beginPath()
        g.moveTo(x, y)
        g.lineTo(px, py)
        g.lineWidth = 1
        g.strokeStyle = 'lightblue'
        g.stroke()

        var begin_x
        var end_x
        
        draw_text(c, g, node.vid ? node.vid.slice(0, 3) : '', x, y + 25, 'grey', 'left', 'middle')
        
        var my_text = node.elems + (node.end_cap ? '*' : '')
        
        draw_text(c, g, my_text, x, y, Object.keys(node.deleted_by).length > 0 ? 'red' : 'blue', 'left', 'middle', '20px Arial')
        
        var width = g.measureText(my_text).width
        x += width

        var px = x
        x += 10
        for (var n of node.nexts) helper(n, y + 40, px, y)
        if (node.next) helper(node.next, y, px, y)
    }
    if (typeof(S) == 'string') helper(sync9_create_space_dag_node('lit', S))
    else helper(S, y, x, y)
}






function create_node() {
    var node = {}
    node.pid = sync9_guid()
    node.keys = {}
    
    function get_key(key) {
        if (!node.keys[key]) node.keys[key] = sync9_create_peer({
            pid: node.pid,
            get: (conn, initial) => {
                node.on_get(key, initial, {conn})
            },
            set: (conn, vid, parents, changes, joiner_num) => {
                node.on_set(key, changes, {version: vid, parents: parents, conn}, joiner_num)
            },
            set_multi: (conn, vs, fs, conn_leaves, min_leaves) => {
                node.on_multiset(key, vs, fs.map(x => ({
                    name: x.a + ':' + x.b + ':' + x.conn,
                    versions: x.nodes,
                    parents: x.parents
                })), conn_leaves, min_leaves, {conn})
            },
            ack: (conn, vid, joiner_num) => {
                node.on_ack(key, null, 'local', {version: vid, conn}, joiner_num)
            },
            full_ack: (conn, vid) => {
                node.on_ack(key, null, 'global', {version: vid, conn})
            },
            fissure: (conn, fissure) => {
                node.on_disconnected(key, fissure.a + ':' + fissure.b + ':' + fissure.conn, fissure.nodes, fissure.parents, {conn})
            }
        })
        return node.keys[key]
    }

    node.get = (key, initial, t) => {
        get_key(key).get(t.conn, initial)
    }
    
    node.set = (key, patches, t, joiner_num) => {
        get_key(key).set(t.conn, t.version, t.parents, patches, joiner_num)
    }
    
    node.multiset = (key, vs, fs, conn_leaves, min_leaves, t) => {
        get_key(key).set_multi(t.conn, vs, fs.map(x => {
            var [a, b, conn] = x.name.split(/:/)
            return {a, b, conn, nodes: x.versions, parents: x.parents}
        }), conn_leaves, min_leaves)
    }
    
    node.forget = (key, t) => {
        get_key(key).forget(t.conn)
    }
    
    node.ack = (key, valid, seen, t, joiner_num) => {
        if (seen == 'local') {
            get_key(key).ack(t.conn, t.version, joiner_num)
        } else if (seen == 'global') {
            get_key(key).full_ack(t.conn, t.version)
        }
    }
    
    node.disconnected = (key, name, versions, parents, t) => {
        var f = null
        if (name) {
            var [a, b, conn] = name.split(/:/)
            f = {
                a, b, conn,
                nodes: versions,
                parents: parents
            }            
        }
        get_key(key).fissure(t.conn, f)
    }
    
    node.delete = () => {
        
        
        // work here: idea: use "undefined" to represent deletion
        
    }
    
    return node
}



function sync9_create_peer(conn_funcs) {
    var self = {}
    self.pid = conn_funcs.pid || sync9_guid()
    self.s9 = sync9_create()
    self.conns = {}
    self.fissures = {}
    self.conn_leaves = {}
    self.ack_leaves = {}
    self.phase_one = {}
    self.joiners = {}
    
    // conn: {
    //      id: connection id,
    //      pid: (optional) peer id, implies symmetric connection
    // }
    self.get = (conn, initial) => {
        self.conns[conn.id] = conn
        if (conn.pid && initial) conn_funcs.get(conn, false)
        var vs = (Object.keys(self.s9.T).length > 0) ? sync9_extract_versions(self.s9, x => false) : []
        var fs = Object.values(self.fissures)
        conn_funcs.set_multi(conn, vs, fs)
    }
    
    self.forget = (conn) => {
        delete self.conns[conn.id]
    }
    
    function get_symmetric_conns() {
        return Object.values(self.conns).filter(c => c.pid)
    }
    
    self.set = (conn, vid, parents, changes, joiner_num) => {
        if (!conn || !self.s9.T[vid] || (joiner_num > self.joiners[vid])) {
            sync9_add_version(self.s9, vid, parents, changes)
            self.phase_one[vid] = {origin: conn, count: get_symmetric_conns().length - (conn ? 1 : 0)}
            if (joiner_num) self.joiners[vid] = joiner_num
            Object.values(self.conns).forEach(c => {
                if (!conn || (c.id != conn.id)) conn_funcs.set(c, vid, parents, changes, joiner_num)
            })
        } else if (self.phase_one[vid] && (joiner_num == self.joiners[vid])) {
            self.phase_one[vid].count--
        }
        check_ack_count(vid)
    }

    self.set_multi = (conn, vs, fs, conn_leaves, min_leaves) => {
        var new_vs = []
        
        var v = vs[0]
        if (v && !v.vid) {
            vs.shift()
            if (!Object.keys(self.s9.T).length) {
                new_vs.push(v)
                sync9_add_version(self.s9, v.vid, v.parents, v.changes)
            }
        }
        
        var vs_T = {}
        vs.forEach(v => vs_T[v.vid] = v.parents)
        vs.forEach(v => {
            if (self.s9.T[v.vid]) {
                function f(v) {
                    if (vs_T[v]) {
                        Object.keys(vs_T[v]).forEach(f)
                        delete vs_T[v]
                    }
                }
                f(v.vid)
            }
        })
        vs.forEach(v => {
            if (vs_T[v.vid]) {
                new_vs.push(v)
                sync9_add_version(self.s9, v.vid, v.parents, v.changes)
            }
        })
        
        var new_fs = []
        var gen_fs = []
        fs.forEach(f => {
            var key = f.a + ':' + f.b + ':' + f.conn
            if (!self.fissures[key]) {
                new_fs.push(f)
                self.fissures[key] = f
                if (f.b == self.pid) gen_fs.push({
                    a: self.pid,
                    b: f.a,
                    conn: f.conn,
                    nodes: f.nodes,
                    parents: {}
                })
            }
        })
        
        if (!conn_leaves) {
            conn_leaves = Object.assign({}, self.s9.leaves)
        }
        var our_conn_nodes = sync9_get_ancestors(self.s9, self.conn_leaves)
        var new_conn_nodes = sync9_get_ancestors(self.s9, conn_leaves)
        Object.keys(self.conn_leaves).forEach(x => {
            if (new_conn_nodes[x] && !conn_leaves[x]) {
                delete self.conn_leaves[x]
            }
        })
        Object.keys(conn_leaves).forEach(x => {
            if (!our_conn_nodes[x]) self.conn_leaves[x] = true
        })
        
        if (!min_leaves) {
            min_leaves = {}
            var min = vs.filter(v => !vs_T[v.vid])
            min.forEach(v => min_leaves[v.vid] = true)
            min.forEach(v => {
                Object.keys(v.parents).forEach(p => {
                    delete min_leaves[p]
                })
            })
        }
        var min_nodes = sync9_get_ancestors(self.s9, min_leaves)
        var ack_nodes = sync9_get_ancestors(self.s9, self.ack_leaves)
        Object.keys(self.ack_leaves).forEach(x => {
            if (!min_nodes[x]) {
                delete self.ack_leaves[x]
            }
        })
        Object.keys(min_leaves).forEach(x => {
            if (ack_nodes[x]) self.ack_leaves[x] = true
        })
        
        self.phase_one = {}
        
        if (new_vs.length > 0 || new_fs.length > 0) {
            Object.values(self.conns).forEach(c => {
                if (c.id != conn.id) conn_funcs.set_multi(c, new_vs, new_fs, conn_leaves, min_leaves)
            })
        }
        gen_fs.forEach(f => self.fissure(null, f))
    }
    
    self.ack = (conn, vid, joiner_num) => {
        if (self.phase_one[vid] && (joiner_num == self.joiners[vid])) {
            self.phase_one[vid].count--
            check_ack_count(vid)
        }
    }
    
    self.full_ack = (conn, vid) => {
        if (!self.s9.T[vid]) return
        
        var ancs = sync9_get_ancestors(self.s9, self.conn_leaves)
        if (ancs[vid]) return
        
        var ancs = sync9_get_ancestors(self.s9, self.ack_leaves)
        if (ancs[vid]) return
        
        add_full_ack_leaf(vid)
        get_symmetric_conns().forEach(c => {
            if (c.id != conn.id) conn_funcs.full_ack(c, vid)
        })
    }
    
    function add_full_ack_leaf(vid) {
        var marks = {}
        function f(v) {
            if (!marks[v]) {
                marks[v] = true
                delete self.conn_leaves[v]
                delete self.ack_leaves[v]
                delete self.phase_one[v]
                delete self.joiners[v]
                Object.keys(self.s9.T[v]).forEach(f)
            }
        }
        f(vid)
        self.ack_leaves[vid] = true
        self.prune()
    }
    
    function check_ack_count(vid) {
        if (self.phase_one[vid] && self.phase_one[vid].count == 0) {
            if (self.phase_one[vid].origin) {
                conn_funcs.ack(self.phase_one[vid].origin, vid, self.joiners[vid])
            } else {
                add_full_ack_leaf(vid)
                get_symmetric_conns().forEach(c => {
                    conn_funcs.full_ack(c, vid)
                })
            }
        }
    }
    
    self.fissure = (conn, fissure) => {
        if (!fissure) {
            if (!self.conns[conn.id]) return
            if (conn.pid) {
                var nodes = {}
                var ack_nodes = sync9_get_ancestors(self.s9, self.ack_leaves)
                Object.keys(self.s9.T).forEach(v => {
                    if (!ack_nodes[v] || self.ack_leaves[v]) {
                        nodes[v] = true
                    }
                })
                
                var parents = {}
                Object.keys(self.fissures).forEach(x => {
                    parents[x] = true
                })
                
                fissure = {
                    a: self.pid,
                    b: conn.pid,
                    conn: conn.id,
                    nodes,
                    parents
                }
            }
            delete self.conns[conn.id]
        }
    
        var key = fissure.a + ':' + fissure.b + ':' + fissure.conn
        if (!self.fissures[key]) {
            self.fissures[key] = fissure
            
            self.phase_one = {}
            
            get_symmetric_conns().forEach(c => {
                if (!conn || (c.id != conn.id)) conn_funcs.fissure(c, fissure)
            })
            
            if (fissure.b == self.pid) {
                self.fissure(null, {
                    a: self.pid,
                    b: fissure.a,
                    conn: fissure.conn,
                    nodes: fissure.nodes,
                    parents: {}
                })
            }
        }
    }
    
    self.prune = () => {
        var unremovable = {}
        Object.entries(self.fissures).forEach(x => {
            if (!self.fissures[x[1].b + ':' + x[1].a + ':' + x[1].conn]) {
                function f(y) {
                    if (!unremovable[y.a + ':' + y.b + ':' + y.conn]) {
                        unremovable[y.a + ':' + y.b + ':' + y.conn] = true
                        unremovable[y.b + ':' + y.a + ':' + y.conn] = true
                        Object.keys(y.parents).forEach(p => {
                            if (self.fissures[p]) f(self.fissures[p])
                        })
                    }
                }
                f(x[1])
            }
        })
        
        var acked = sync9_get_ancestors(self.s9, self.ack_leaves)
        var done = {}
        Object.entries(self.fissures).forEach(x => {
            var other_key = x[1].b + ':' + x[1].a + ':' + x[1].conn
            var other = self.fissures[other_key]
            if (other && !done[x[0]] && !unremovable[x[0]]) {
                done[x[0]] = true
                done[other_key] = true
                
                if (Object.keys(x[1].nodes).every(x => acked[x] || !self.s9.T[x])) {
                    delete self.fissures[x[0]]
                    delete self.fissures[other_key]
                }
            }
        })
        
        var tags = {'null': {tags: {}}}
        var frozen = {}
        Object.keys(self.s9.T).forEach(vid => {
            tags[vid] = {tags: {}}
        })
        function tag(vid, t) {
            if (!tags[vid].tags[t]) {
                tags[vid].tags[t] = true
                Object.keys(self.s9.T[vid]).forEach(vid => tag(vid, t))
                tags[null].tags[t] = true
            }
        }
        Object.entries(self.fissures).forEach(x => {
            Object.keys(x[1].nodes).forEach(v => {
                if (!self.s9.T[v]) return
                tag(v, v)
                frozen[v] = true
                Object.keys(self.s9.T[v]).forEach(v => {
                    tag(v, v)
                    frozen[v] = true
                })
            })
        })
        var acked = sync9_get_ancestors(self.s9, self.ack_leaves)
        Object.keys(self.s9.T).forEach(x => {
            if (!acked[x] || self.ack_leaves[x]) {
                tag(x, x)
                frozen[x] = true
                Object.keys(self.s9.T[x]).forEach(v => {
                    tag(v, v)
                    frozen[v] = true
                })
            }
        })
        Object.entries(tags).forEach(x => {
            var keys = Object.keys(x[1].tags)
            if (keys.length == 0) {
                frozen[x[0]] = true
            } else if (!frozen[x[0]]) {
                x[1].tag = keys.sort().join(',')
            }
        })
        var q = (a, b) => {
            if (!a) a = 'null'
            return a && b && !frozen[a] && !frozen[b] && (tags[a].tag == tags[b].tag)
        }
        sync9_prune2(self.s9, q, q)

        var leaves = Object.keys(self.s9.leaves)
        var ack_leaves = Object.keys(self.ack_leaves)
        var fiss = Object.keys(self.fissures)
        if (leaves.length == 1 && ack_leaves.length == 1 && leaves[0] == ack_leaves[0] && fiss.length == 0) {
            self.s9.T = {
                [leaves[0]]: {}
            }
            var val = sync9_read(self.s9)
            self.s9.val = (val && typeof(val) == 'object') ? {t: 'lit', S: val} : val
        }
    }
    
    self.create_joiner = () => {
        var vid = sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(Object.keys(self.s9.leaves).sort().join(':')))
        var joiner_num = Math.random()
        self.set(null, vid, Object.assign({}, self.s9.leaves), [], joiner_num)
    }
    
    return self
}




function sync9_extract_versions(s9, is_anc) {
    var is_lit = x => !x || typeof(x) != 'object' || x.t == 'lit'
    var get_lit = x => (x && typeof(x) == 'object' && x.t == 'lit') ? x.S : x
    
    var versions = [{
        vid: null,
        parents: {},
        changes: [` = ${JSON.stringify(sync9_read(s9, is_anc))}`]
    }]
    Object.keys(s9.T).filter(x => !is_anc(x)).forEach(vid => {
        var ancs = sync9_get_ancestors(s9, {[vid]: true})
        delete ancs[vid]
        var is_anc = x => ancs[x]
        var path = []
        var changes = []
        rec(s9.val)
        function rec(x) {
            if (is_lit(x)) {
            } else if (x.t == 'val') {
                sync9_space_dag_extract_version(x.S, s9, vid, is_anc).forEach(s => {
                    if (s[2].length) changes.push(`${path.join('')} = ${JSON.stringify(s[2][0])}`)
                })
                sync9_trav_space_dag(x.S, is_anc, node => {
                    node.elems.forEach(rec)
                })
            } else if (x.t == 'arr') {
                sync9_space_dag_extract_version(x.S, s9, vid, is_anc).forEach(s => {
                    changes.push(`${path.join('')}[${s[0]}:${s[0] + s[1]}] = ${JSON.stringify(s[2])}`)
                })
                var i = 0
                sync9_trav_space_dag(x.S, is_anc, node => {
                    node.elems.forEach(e => {
                        path.push(`[${i++}]`)
                        rec(e)
                        path.pop()
                    })
                })
            } else if (x.t == 'obj') {
                Object.entries(x.S).forEach(e => {
                    path.push('[' + JSON.stringify(e[0]) + ']')
                    rec(e[1])
                    path.pop()
                })
            } else if (x.t == 'str') {
                sync9_space_dag_extract_version(x.S, s9, vid, is_anc).forEach(s => {
                    changes.push(`${path.join('')}[${s[0]}:${s[0] + s[1]}] = ${JSON.stringify(s[2])}`)
                })
            }
        }
        
        versions.push({
            vid,
            parents: Object.assign({}, s9.T[vid]),
            changes
        })
    })
    return versions
}

function sync9_space_dag_extract_version(S, s9, vid, is_anc) {
    var splices = []
    
    function add_result(offset, del, ins) {
        if (typeof(ins) != 'string')
            ins = ins.map(x => sync9_read(x, () => false))
        if (splices.length > 0) {
            var prev = splices[splices.length - 1]
            if (prev[0] + prev[1] == offset) {
                prev[1] += del
                prev[2] = prev[2].concat(ins)
                return
            }
        }
        splices.push([offset, del, ins])
    }
    
    var offset = 0
    function helper(node, _vid) {
        if (_vid == vid) {
            add_result(offset, 0, node.elems.slice(0))
        } else if (node.deleted_by[vid] && node.elems.length > 0) {
            add_result(offset, node.elems.length, node.elems.slice(0, 0))
        }
        
        if ((!_vid || is_anc(_vid)) && !Object.keys(node.deleted_by).some(is_anc)) {
            offset += node.elems.length
        }
        
        node.nexts.forEach(next => helper(next, next.vid))
        if (node.next) helper(node.next, _vid)
    }
    helper(S, null)
    return splices
}



function sync9_prune2(x, has_everyone_whos_seen_a_seen_b, has_everyone_whos_seen_a_seen_b2) {
    var seen_nodes = {}
    var is_lit = x => !x || typeof(x) != 'object' || x.t == 'lit'
    var get_lit = x => (x && typeof(x) == 'object' && x.t == 'lit') ? x.S : x
    function rec(x) {
        if (is_lit(x)) return x
        if (x.t == 'val') {
            sync9_space_dag_prune2(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)
            sync9_trav_space_dag(x.S, () => true, node => {
                node.elems = node.elems.slice(0, 1).map(rec)
            }, true)
            if (x.S.nexts.length == 0 && !x.S.next && x.S.elems.length == 1 && is_lit(x.S.elems[0])) return x.S.elems[0]
            return x
        }
        if (x.t == 'arr') {
            sync9_space_dag_prune2(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)
            sync9_trav_space_dag(x.S, () => true, node => {
                node.elems = node.elems.map(rec)
            }, true)
            if (x.S.nexts.length == 0 && !x.S.next && x.S.elems.every(is_lit) && !Object.keys(x.S.deleted_by).length) return {t: 'lit', S: x.S.elems.map(get_lit)}
            return x
        }
        if (x.t == 'obj') {
            Object.entries(x.S).forEach(e => x.S[e[0]] = rec(e[1]))
            if (Object.values(x.S).every(is_lit)) {
                var o = {}
                Object.entries(x.S).forEach(e => o[e[0]] = get_lit(e[1]))
                return {t: 'lit', S: o}
            }
            return x
        }
        if (x.t == 'str') {
            sync9_space_dag_prune2(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)
            if (x.S.nexts.length == 0 && !x.S.next && !Object.keys(x.S.deleted_by).length) return x.S.elems
            return x
        }
    }
    x.val = rec(x.val)

    var delete_us = {}
    var children = {}
    Object.keys(x.T).forEach(y => {
        Object.keys(x.T[y]).forEach(z => {
            if (!children[z]) children[z] = {}
            children[z][y] = true
        })
    })
    Object.keys(x.T).forEach(y => {
        if (!seen_nodes[y] && Object.keys(children[y] || {}).some(z => has_everyone_whos_seen_a_seen_b2(y, z))) delete_us[y] = true
    })

    var visited = {}
    var forwards = {}
    function g(vid) {
        if (visited[vid]) return
        visited[vid] = true
        if (delete_us[vid])
            forwards[vid] = {}
        Object.keys(x.T[vid]).forEach(pid => {
            g(pid)
            if (delete_us[vid]) {
                if (delete_us[pid])
                    Object.assign(forwards[vid], forwards[pid])
                else
                    forwards[vid][pid] = true
            } else if (delete_us[pid]) {
                delete x.T[vid][pid]
                Object.assign(x.T[vid], forwards[pid])
            }
        })
    }
    Object.keys(x.leaves).forEach(g)
    Object.keys(delete_us).forEach(vid => delete x.T[vid])
    return delete_us
}

function sync9_space_dag_prune2(S, has_everyone_whos_seen_a_seen_b, seen_nodes) {
    function set_nnnext(node, next) {
        while (node.next) node = node.next
        node.next = next
    }
    function process_node(node, offset, vid, prev) {
        var nexts = node.nexts
        var next = node.next
        
        var all_nexts_prunable = nexts.every(x => has_everyone_whos_seen_a_seen_b(vid, x.vid))
        if (nexts.length > 0 && all_nexts_prunable) {
            var first_prunable = 0
            var gamma = next
            if (first_prunable + 1 < nexts.length) {
                gamma = sync9_create_space_dag_node(null, typeof(node.elems) == 'string' ? '' : [])
                gamma.nexts = nexts.slice(first_prunable + 1)
                gamma.next = next
            }
            if (first_prunable == 0) {
                if (nexts[0].elems.length == 0 && !nexts[0].end_cap && nexts[0].nexts.length > 0) {
                    var beta = gamma
                    if (nexts[0].next) {
                        beta = nexts[0].next
                        set_nnnext(beta, gamma)
                    }
                    node.nexts = nexts[0].nexts
                    node.next = beta
                } else {
                    delete node.end_cap
                    node.nexts = []
                    node.next = nexts[0]
                    node.next.vid = null
                    set_nnnext(node, gamma)
                }
            } else {
                node.nexts = nexts.slice(0, first_prunable)
                node.next = nexts[first_prunable]
                node.next.vid = null
                set_nnnext(node, gamma)
            }
            return true
        }
        
        if (Object.keys(node.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k))) {
            node.deleted_by = {}
            node.elems = node.elems.slice(0, 0)
            delete node.gash
            return true
        } else {
            Object.assign(seen_nodes, node.deleted_by)
        }
        
        if (next && !next.nexts[0] && (Object.keys(next.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k)) || next.elems.length == 0)) {
            node.next = next.next
            return true
        }
        
        if (nexts.length == 0 && next &&
            !(next.elems.length == 0 && !next.end_cap && next.nexts.length > 0) &&
            Object.keys(node.deleted_by).every(x => next.deleted_by[x]) &&
            Object.keys(next.deleted_by).every(x => node.deleted_by[x])) {
            node.elems = node.elems.concat(next.elems)
            node.end_cap = next.end_cap
            node.nexts = next.nexts
            node.next = next.next
            return true
        }
    }
    
    var did_something_ever = false
    var did_something_this_time = true
    while (did_something_this_time) {
        did_something_this_time = false
        sync9_trav_space_dag(S, () => true, (node, offset, has_nexts, prev, vid) => {
            if (process_node(node, offset, vid, prev)) {
                did_something_this_time = true
                did_something_ever = true
            }
        }, true)
    }
    sync9_trav_space_dag(S, () => true, (node, offset, has_nexts, prev, vid) => {
        if (vid) seen_nodes[vid] = true
    }, true)
    return did_something_ever
}









function sync9_create() {
    return {
        T: {},
        leaves: {},
        val: null
    }
}

function sync9_add_version(x, vid, parents, changes, is_anc) {
    let make_lit = x => (x && typeof(x) == 'object') ? {t: 'lit', S: x} : x
    
    if (!vid && Object.keys(x.T).length == 0) {
        var parse = sync9_parse_change(changes[0])
        x.val = make_lit(parse.val)
        return
    } else if (!vid) return
    
    if (x.T[vid]) return
    x.T[vid] = Object.assign({}, parents)
    
    Object.keys(parents).forEach(k => {
        if (x.leaves[k]) delete x.leaves[k]
    })
    x.leaves[vid] = true
    
    if (!is_anc) {
        if (parents == x.leaves) {
            is_anc = (_vid) => _vid != vid
        } else {
            var ancs = sync9_get_ancestors(x, parents)
            is_anc = _vid => ancs[_vid]
        }
    }
    
    changes.forEach(change => {
        var parse = sync9_parse_change(change)
        var cur = x.val
        if (!cur || typeof(cur) != 'object' || cur.t == 'lit')
            cur = x.val = {t: 'val', S: sync9_create_space_dag_node(null, [cur])}
        var prev_S = null
        var prev_i = 0
        each(parse.keys, (key, i) => {
            if (cur.t == 'val') cur = sync9_space_dag_get(prev_S = cur.S, prev_i = 0, is_anc)
            if (cur.t == 'lit') {
                var new_cur = {}
                if (cur.S instanceof Array) {
                    new_cur.t = 'arr'
                    new_cur.S = sync9_create_space_dag_node(null, cur.S.map(x => make_lit(x)))
                } else {
                    if (typeof(cur.S) != 'object') throw 'bad'
                    new_cur.t = 'obj'
                    new_cur.S = {}
                    Object.entries(cur.S).forEach(e => new_cur.S[e[0]] = make_lit(e[1]))
                }
                cur = new_cur
                sync9_space_dag_set(prev_S, prev_i, cur, is_anc)
            }
            if (cur.t == 'obj') {
                let x = cur.S[key]
                if (!x || typeof(x) != 'object' || x.t == 'lit')
                    x = cur.S[key] = {t: 'val', S: sync9_create_space_dag_node(null, [x])}
                cur = x
            } else if (i == parse.keys.length - 1 && !parse.range) {
                parse.range = [key, key + 1]
                parse.val = (cur.t == 'str') ? parse.val : [parse.val]
            } else if (cur.t == 'arr') {
                cur = sync9_space_dag_get(prev_S = cur.S, prev_i = key, is_anc)
            } else throw 'bad'
        })
        if (!parse.range) {
            if (cur.t != 'val') throw 'bad'
            var len = sync9_space_dag_length(cur.S, is_anc)
            sync9_space_dag_add_version(cur.S, vid, [[0, len, [make_lit(parse.val)]]], is_anc)
        } else {
            if (cur.t == 'val') cur = sync9_space_dag_get(prev_S = cur.S, prev_i = 0, is_anc)
            if (typeof(cur) == 'string') {
                cur = {t: 'str', S: sync9_create_space_dag_node(null, cur)}
                sync9_space_dag_set(prev_S, prev_i, cur, is_anc)
            } else if (cur.t == 'lit') {
                if (!(cur.S instanceof Array)) throw 'bad'
                cur = {t: 'arr', S: sync9_create_space_dag_node(null, cur.S.map(x => make_lit(x)))}
                sync9_space_dag_set(prev_S, prev_i, cur, is_anc)
            }
            

            
            // work here
            if (parse.val instanceof Array && cur.t != 'arr') {
                debugger
            }
            
            
            
            
            if (parse.val instanceof String && cur.t != 'str') throw 'bad'
            if (parse.val instanceof Array) parse.val = parse.val.map(x => make_lit(x))
            sync9_space_dag_add_version(cur.S, vid, [[parse.range[0], parse.range[1] - parse.range[0], parse.val]], is_anc)
        }
    })
}

function sync9_read(x, is_anc) {
    if (!is_anc) is_anc = () => true
    if (x && typeof(x) == 'object') {
        if (!x.t) return sync9_read(x.val, is_anc)
        if (x.t == 'lit') return x.S
        if (x.t == 'val') return sync9_read(sync9_space_dag_get(x.S, 0, is_anc), is_anc)
        if (x.t == 'obj') {
            var o = {}
            Object.entries(x.S).forEach(([k, v]) => {
                o[k] = sync9_read(v, is_anc)
            })
            return o
        }
        if (x.t == 'arr') {
            var a = []
            sync9_trav_space_dag(x.S, is_anc, (node) => {
                node.elems.forEach((e) => {
                    a.push(sync9_read(e, is_anc))
                })
            })
            return a
        }
        if (x.t == 'str') {
            var s = []
            sync9_trav_space_dag(x.S, is_anc, (node) => {
                s.push(node.elems)
            })
            return s.join('')
        }
        throw 'bad'
    } return x
}

function sync9_create_space_dag_node(vid, elems, end_cap) {
    return {
        vid : vid,
        elems : elems,
        deleted_by : {},
        end_cap : end_cap,
        nexts : [],
        next : null
    }
}

function sync9_space_dag_get(S, i, is_anc) {
    var ret = null
    var offset = 0
    sync9_trav_space_dag(S, is_anc ? is_anc : () => true, (node) => {
        if (i - offset < node.elems.length) {
            ret = node.elems[i - offset]
            return false
        }
        offset += node.elems.length
    })
    return ret
}

function sync9_space_dag_set(S, i, v, is_anc) {
    var offset = 0
    sync9_trav_space_dag(S, is_anc ? is_anc : () => true, (node) => {
        if (i - offset < node.elems.length) {
            node.elems[i - offset] = v
            return false
        }
        offset += node.elems.length
    })
}

function sync9_space_dag_length(S, is_anc) {
    var count = 0
    sync9_trav_space_dag(S, is_anc ? is_anc : () => true, node => {
        count += node.elems.length
    })
    return count
}

function sync9_space_dag_break_node(node, x, end_cap, new_next) {
    function subseq(x, start, stop) {
        return (x instanceof Array) ?
            x.slice(start, stop) :
            x.substring(start, stop)
    }
    
    var tail = sync9_create_space_dag_node(null, subseq(node.elems, x), node.end_cap)
    Object.assign(tail.deleted_by, node.deleted_by)
    tail.nexts = node.nexts
    tail.next = node.next
    
    node.elems = subseq(node.elems, 0, x)
    node.end_cap = end_cap
    if (end_cap) tail.gash = true
    node.nexts = new_next ? [new_next] : []
    node.next = tail
    
    return tail
}

function sync9_space_dag_add_version(S, vid, splices, is_anc) {
    
    function add_to_nexts(nexts, to) {
        var i = binarySearch(nexts, function (x) {
            if (to.vid < x.vid) return -1
            if (to.vid > x.vid) return 1
            return 0
        })
        nexts.splice(i, 0, to)
    }
    
    var si = 0
    var delete_up_to = 0
    
    var cb = (node, offset, has_nexts, prev, _vid, deleted) => {
        var s = splices[si]
        if (!s) return false
        
        if (deleted) {
            if (s[1] == 0 && s[0] == offset) {
                if (node.elems.length == 0 && !node.end_cap && has_nexts) return
                var new_node = sync9_create_space_dag_node(vid, s[2])
                if (node.elems.length == 0 && !node.end_cap)
                    add_to_nexts(node.nexts, new_node)
                else
                    sync9_space_dag_break_node(node, 0, undefined, new_node)
                si++
            }
            return            
        }
        
        if (s[1] == 0) {
            var d = s[0] - (offset + node.elems.length)
            if (d > 0) return
            if (d == 0 && !node.end_cap && has_nexts) return
            var new_node = sync9_create_space_dag_node(vid, s[2])
            if (d == 0 && !node.end_cap) {
                add_to_nexts(node.nexts, new_node)
            } else {
                sync9_space_dag_break_node(node, s[0] - offset, undefined, new_node)
            }
            si++
            return
        }
        
        if (delete_up_to <= offset) {
            var d = s[0] - (offset + node.elems.length)
            if (d >= 0) return
            delete_up_to = s[0] + s[1]
            
            if (s[2]) {
                var new_node = sync9_create_space_dag_node(vid, s[2])
                if (s[0] == offset && node.gash) {
                    if (!prev.end_cap) throw 'no end_cap?'
                    add_to_nexts(prev.nexts, new_node)
                } else {
                    sync9_space_dag_break_node(node, s[0] - offset, true, new_node)
                    return
                }
            } else {
                if (s[0] == offset) {
                } else {
                    sync9_space_dag_break_node(node, s[0] - offset)
                    return
                }
            }
        }
        
        if (delete_up_to > offset) {
            if (delete_up_to <= offset + node.elems.length) {
                if (delete_up_to < offset + node.elems.length) {
                    sync9_space_dag_break_node(node, delete_up_to - offset)
                }
                si++
            }
            node.deleted_by[vid] = true
            return
        }
    }
    
    var f = is_anc
    var exit_early = {}
    var offset = 0
    function helper(node, prev, vid) {
        var has_nexts = node.nexts.find(next => f(next.vid))
        var deleted = Object.keys(node.deleted_by).some(vid => f(vid))
        if (cb(node, offset, has_nexts, prev, vid, deleted) == false)
            throw exit_early
        if (!deleted) {
            offset += node.elems.length
        }
        for (var next of node.nexts)
            if (f(next.vid)) helper(next, null, next.vid)
        if (node.next) helper(node.next, node, vid)
    }
    try {
        
        
        
        if (!S) {
            debugger
        }
        
        
        helper(S, null, S.vid)
        
        
    } catch (e) {
        if (e != exit_early) throw e
    }
    
}

function sync9_trav_space_dag(S, f, cb, view_deleted, tail_cb) {
    var exit_early = {}
    var offset = 0
    function helper(node, prev, vid) {
        var has_nexts = node.nexts.find(next => f(next.vid))
        if (view_deleted ||
            !Object.keys(node.deleted_by).some(vid => f(vid))) {
            if (cb(node, offset, has_nexts, prev, vid) == false)
                throw exit_early
            offset += node.elems.length
        }
        for (var next of node.nexts)
            if (f(next.vid)) helper(next, null, next.vid)
        if (node.next) helper(node.next, node, vid)
        else if (tail_cb) tail_cb(node)
    }
    try {
        helper(S, null, S.vid)
    } catch (e) {
        if (e != exit_early) throw e
    }
}

function sync9_get_ancestors(x, vids) {
    var ancs = {}
    function mark_ancs(key) {
        if (!ancs[key]) {
            ancs[key] = true
            Object.keys(x.T[key]).forEach(mark_ancs)
        }
    }
    Object.keys(vids).forEach(mark_ancs)
    return ancs
}

function sync9_parse_change(change) {
    var ret = { keys : [] }
    var re = /\.?([^\.\[ =]+)|\[((\-?\d+)(:\-?\d+)?|'(\\'|[^'])*'|"(\\"|[^"])*")\]|\s*=\s*(.*)/g
    var m
    while (m = re.exec(change)) {
        if (m[1])
            ret.keys.push(m[1])
        else if (m[2] && m[4])
            ret.range = [
                JSON.parse(m[3]),
                JSON.parse(m[4].substr(1))
            ]
        else if (m[2])
            ret.keys.push(JSON.parse(m[2]))
        else if (m[7])
            ret.val = JSON.parse(m[7])
    }
    
    return ret
}

function sync9_diff_ODI(a, b) {
    var offset = 0
    var prev = null
    var ret = []
    var d = diff_main(a, b)
    for (var i = 0; i < d.length; i++) {
        if (d[i][0] == 0) {
            if (prev) ret.push(prev)
            prev = null
            offset += d[i][1].length
        } else if (d[i][0] == 1) {
            if (prev)
                prev[2] += d[i][1]
            else
                prev = [offset, 0, d[i][1]]
        } else {
            if (prev)
                prev[1] += d[i][1].length
            else
                prev = [offset, d[i][1].length, '']
            offset += d[i][1].length
        }
    }
    if (prev) ret.push(prev)
    return ret
}

function sync9_guid() {
    var x = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    var s = []
    for (var i = 0; i < 15; i++)
        s.push(x[Math.floor(Math.random() * x.length)])
    return s.join('')
}

function sync9_create_proxy(x, cb, path) {
    path = path || ''
    var child_path = key => path + '[' + JSON.stringify(key) + ']'
    return new Proxy(x, {
        get : (x, key) => {
            if (['copyWithin', 'reverse', 'sort', 'fill'].includes(key))
                throw 'proxy does not support function: ' + key
            if (key == 'push') return function () {
                var args = Array.from(arguments)
                cb([path + '[' + x.length + ':' + x.length + '] = ' + JSON.stringify(args)])
                return x.push.apply(x, args)
            }
            if (key == 'pop') return function () {
                cb([path + '[' + (x.length - 1) + ':' + x.length + '] = []'])
                return x.pop()
            }
            if (key == 'shift') return function () {
                cb([path + '[0:1] = []'])
                return x.shift()
            }
            if (key == 'unshift') return function () {
                var args = Array.from(arguments)
                cb([path + '[0:0] = ' + JSON.stringify(args)])
                return x.unshift.apply(x, args)
            }
            if (key == 'splice') return function () {
                var args = Array.from(arguments)
                cb([child_path(key) + '[' + args[0] + ':' + (args[0] + args[1]) + '] = ' + JSON.stringify(args.slice(2))])
                return x.splice.apply(x, args)
            }
            
            var y = x[key]
            if (y && typeof(y) == 'object') {
                return sync9_create_proxy(y, cb, child_path(key))
            } else return y
        },
        set : (x, key, val) => {
            if (typeof(val) == 'string' && typeof(x[key]) == 'string') {
                cb(sync9_diff_ODI(x[key], val).map(splice => {
                    return child_path(key) + '[' + splice[0] + ':' + (splice[0] + splice[1]) + '] = ' + JSON.stringify(splice[2])
                }))
            } else {
                if ((x instanceof Array) && key.match(/^\d+$/)) key = +key
                cb([child_path(key) + ' = ' + JSON.stringify(val)])
            }
            x[key] = val
            return true
        }
    })
}

function sync9_prune(x, has_everyone_whos_seen_a_seen_b, has_everyone_whos_seen_a_seen_b_2) {
    var seen_nodes = {}
    var did_something = true
    function rec(x) {
        if (x && typeof(x) == 'object') {
            if (!x.t && x.val) {
                rec(x.val)
            } else if (x.t == 'val') {
                if (sync9_space_dag_prune(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
                rec(sync9_space_dag_get(x.S, 0))
            } else if (x.t == 'obj') {
                Object.values(x.S).forEach(v => rec(v))
            } else if (x.t == 'arr') {
                if (sync9_space_dag_prune(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
                sync9_trav_space_dag(x.S, () => true, node => {
                    node.elems.forEach(e => rec(e))
                })
            } else if (x.t == 'str') {
                if (sync9_space_dag_prune(x.S, has_everyone_whos_seen_a_seen_b, seen_nodes)) did_something = true
            }
        }
    }
    while (did_something) {
        did_something = false
        rec(x)
    }

    var visited = {}    
    var delete_us = {}
    function f(vid) {
        if (visited[vid]) return
        visited[vid] = true
        Object.keys(x.T[vid]).forEach(pid => {
            if (has_everyone_whos_seen_a_seen_b_2(pid, vid) && !seen_nodes[pid]) {
                delete_us[pid] = true
            }
            f(pid)
        })
    }
    Object.keys(x.leaves).forEach(f)

    var visited = {}
    var forwards = {}
    function g(vid) {
        if (visited[vid]) return
        visited[vid] = true
        if (delete_us[vid])
            forwards[vid] = {}
        Object.keys(x.T[vid]).forEach(pid => {
            g(pid)
            if (delete_us[vid]) {
                if (delete_us[pid])
                    Object.assign(forwards[vid], forwards[pid])
                else
                    forwards[vid][pid] = true
            } else if (delete_us[pid]) {
                delete x.T[vid][pid]
                Object.assign(x.T[vid], forwards[pid])
            }
        })
    }
    Object.keys(x.leaves).forEach(g)
    Object.keys(delete_us).forEach(vid => delete x.T[vid])
    return delete_us
}

function sync9_space_dag_prune(S, has_everyone_whos_seen_a_seen_b, seen_nodes) {
    function set_nnnext(node, next) {
        while (node.next) node = node.next
        node.next = next
    }
    function process_node(node, offset, vid, prev) {
        var nexts = node.nexts
        var next = node.next

        var first_prunable = nexts.findIndex(x => has_everyone_whos_seen_a_seen_b(vid, x.vid))
        if (first_prunable > 0 && (node.elems.length > 0 || !prev)) {
            first_prunable = nexts.findIndex((x, i) => (i > first_prunable) && has_everyone_whos_seen_a_seen_b(vid, x.vid))
        }
        
        if (first_prunable >= 0) {
            var gamma = next
            if (first_prunable + 1 < nexts.length) {
                gamma = sync9_create_space_dag_node(null, typeof(node.elems) == 'string' ? '' : [])
                gamma.nexts = nexts.slice(first_prunable + 1)
                gamma.next = next
            }
            if (first_prunable == 0) {
                if (nexts[0].elems.length == 0 && !nexts[0].end_cap && nexts[0].nexts.length > 0) {
                    var beta = gamma
                    if (nexts[0].next) {
                        beta = nexts[0].next
                        set_nnnext(beta, gamma)
                    }
                    node.nexts = nexts[0].nexts
                    node.next = beta
                } else {
                    delete node.end_cap
                    node.nexts = []
                    node.next = nexts[0]
                    node.next.vid = null
                    set_nnnext(node, gamma)
                }
            } else {
                node.nexts = nexts.slice(0, first_prunable)
                node.next = nexts[first_prunable]
                node.next.vid = null
                set_nnnext(node, gamma)
            }
            return true
        }
        
        if (Object.keys(node.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k))) {
            node.deleted_by = {}
            node.elems = typeof(node.elems) == 'string' ? '' : []
            delete node.gash
            return true
        } else {
            Object.assign(seen_nodes, node.deleted_by)
        }
        
        if (next && !next.nexts[0] && (Object.keys(next.deleted_by).some(k => has_everyone_whos_seen_a_seen_b(vid, k)) || next.elems.length == 0)) {
            node.next = next.next
            return true
        }
        
        if (nexts.length == 0 && next &&
            !(next.elems.length == 0 && !next.end_cap && next.nexts.length > 0) &&
            Object.keys(node.deleted_by).every(x => next.deleted_by[x]) &&
            Object.keys(next.deleted_by).every(x => node.deleted_by[x])) {
            node.elems = node.elems.concat(next.elems)
            node.end_cap = next.end_cap
            node.nexts = next.nexts
            node.next = next.next
            return true
        }
    }
    var did_something = false
    sync9_trav_space_dag(S, () => true, (node, offset, has_nexts, prev, vid) => {
        if (!prev) seen_nodes[vid] = true
        while (process_node(node, offset, vid, prev)) {
            did_something = true
        }
    }, true)
    return did_something
}

// modified from https://stackoverflow.com/questions/22697936/binary-search-in-javascript
function binarySearch(ar, compare_fn) {
    var m = 0;
    var n = ar.length - 1;
    while (m <= n) {
        var k = (n + m) >> 1;
        var cmp = compare_fn(ar[k]);
        if (cmp > 0) {
            m = k + 1;
        } else if(cmp < 0) {
            n = k - 1;
        } else {
            return k;
        }
    }
    return m;
}






function deep_equals(a, b) {
    if (typeof(a) != 'object' || typeof(b) != 'object') return a == b
    if (a == null) return b == null
    if (Array.isArray(a)) {
        if (!Array.isArray(b)) return false
        if (a.length != b.length) return false
        for (var i = 0; i < a.length; i++)
            if (!deep_equals(a[i], b[i])) return false
        return true
    }
    var ak = Object.keys(a).sort()
    var bk = Object.keys(b).sort()
    if (ak.length != bk.length) return false
    for (var k of ak)
        if (!deep_equals(a[k], b[k])) return false
    return true
}






function each(o, cb) {
    if (o instanceof Array) {
        for (var i = 0; i < o.length; i++) {
            if (cb(o[i], i, o) == false)
                return false
        }
    } else {
        for (var k in o) {
            if (o.hasOwnProperty(k)) {
                if (cb(o[k], k, o) == false)
                    return false
            }
        }
    }
    return true
}

function map(o, func) {
    if (o instanceof Array) {
        var accum = []
        for (var i = 0; i < o.length; i++)
            accum[i] = func(o[i], i, o)
        return accum
    } else {
        var accum = {}
        for (var k in o)
            if (o.hasOwnProperty(k))
                accum[k] = func(o[k], k, o)
        return accum
    }
}

function wget(url, cb) {
    var r = new XMLHttpRequest()
    r.addEventListener("load", function () {
        cb(this.responseText)
    })
    r.open("GET", url)
    r.send()
}




function lerp(t0, v0, t1, v1, t) {
    function inner_lerp(t0, v0, t1, v1, t) {
        return (t - t0) * (v1 - v0) / (t1 - t0) + v0
    }
    if (typeof(v0) == 'object') {
        return v0.map((x, i) => inner_lerp(t0, x, t1, v1[i], t))
    } else return inner_lerp(t0, v0, t1, v1, t)
}

function mul(a, s) {
    return a.map(a => a * s)
}

function rot(a, r) {
    return [
        a[0] * Math.cos(r) + a[1] * -Math.sin(r),
        a[0] * Math.sin(r) + a[1] * Math.cos(r)]
}

function sum(a) {
    return a.reduce((a, b) => a + b, 0)
}

function lenSq(a) {
    return sum(a.map(x => x*x))
}

function len(a) {
    return Math.sqrt(lenSq(a))
}

function norm(a) {
    return mul(a, 1 / len(a))
}

function add(a, b) {
    return a.map((a, i) => a + b[i])
}

function sub(a, b) {
    return a.map((a, i) => a - b[i])
}







main()




</script>
