

<pre>

Let's create a data structure and API for syncronizing some text between two editors. Here's a first attempt.

---

Simple Insertion Algorithm

data structure:

data_tree = pointer to a node of the form:
    text -- the raw text in this node
    children -- pointers to child nodes

functions:

insert_text(position, text):

    // create a new data node
    new_data_node = {
        text: text from input arguments,
        children: empty array
    }
    
    // insert our new data node
    do pre-order traversal of data_tree, counting the characters in each text until we reach position:
    
    - if we are coincidentally at the end of a node, great, just insert our new_data_node into this node's children
    
    - if the position is somewhere in the middle of this node's text, then we'll need to split this node into two nodes. The front node will contain the text before the position, and it will have two children, one being new_data_node, and the other being the second half of this node, which will contain the rest of the text, and will inherit the children from the original node.
    
    // return the new total text
    do pre-order traversal of data_tree, concatenating all the texts into a giant text and returning that

---

Ok, that's a good start, however, this notion of "position" is going to get messed up between editors. For example, say two people are editing "cat", and person A inserts "cute " at the beginning, and person B inserts "s are great" at the end (at position 3). Now when person A receives the insertion from person B, and they try to insert it into "cute cat" at position 3, they'll get "cuts are great cat", instead of the desired "cute cats are great". The idea of operational transform would be to alert that number 3 to the number 8, in this example. We'll instead go with the CRDT approach which is to handle this issue with version information in the data structure itself.

---

Simple Insertion Algorithm with Versions

data structure:

NEW! version_to_parents = map of version ids to sets, where each set contains the parent version ids of the given version

data_tree = pointer to a node of the form:
    NEW! version_id -- a globally unique id, may be null
    ..rest as before

functions:

insert_text(NEW! version_id, NEW! parent_ids, position, text):

    // NEW: add this version to our versions
    version_to_parents[version_id] = parent_ids

    // create a new tree node
    new_data_node = {
        ...
        NEW! version_id: version_id from input arguments,
        ...
    }
    
    // insert our new data node
    do pre-order traversal of data_tree, counting the characters in each text until we reach position:
    
    - if we are coincidentally at the end of a node, great, just insert our new_data_node into this node's children
    
    - if the position is somewhere in the middle of this node's text, then we'll need to split this node into two nodes. The front node will contain the text before the position, and it will have two children, one being new_data_node, and the other being the second half of this node, which will contain the rest of the text, and will inherit the children from the original node.
    
    // return the new total text
    do pre-order traversal of data_tree, concatenating all the texts into a giant text and returning that




---

Ok, that's great, except there are some merging issues -- if two people insert text at the same location at the same time, on different machines, how do we ensure that they'll appear in the same order on both machines once they both receive each other's insertions?

---

Simple Insertion Algorithm with Better Merging










version_to_parents = map of version ids to sets, where each set contains the parent version ids of the given version

data_tree = pointer to a node of the form:
    version_id -- can be null
    text -- the raw text in this node
    children -- pointers to child nodes, sorted by version_id, with null's sorted last

insert_text(version_id, parent_ids, position, text):

    // add this version to our versions
    version_to_parents[version_id] = parent_ids

    // create a new tree node
    new_data_node = {
        version_id: make up a new globally unique id,
        text: text from input,
        children: empty array
    }
    
    // insert our new tree node
    do pre-order traversal of data_tree, counting the characters in each text until we reach position:
    
    - if we are coincidentally at the end of a node, great, just insert our new_data_node into this node's children (insert it into the correct place according to the sorting rules above)
    
    - if the position is somewhere in the middle of this node's text, then we'll need to split this node into two nodes. The front node will contain the text before the position, and it will have two children, one being new_data_node, and the other being the second half of this node, which will contain the rest of the text, and will inherit the children from the original node (it will also have a version_id of null, so that it gets sorted after new_data_node).
    
    // return the new total text
    do pre-order traversal of data_tree, concatenating all the texts into a giant text and return that









    
    
    
    
    Preorder Traversal
    




---


how does it work?

Layer 1:

Data structures:

time dag: map of version ids to parent-sets (each parent-set is a set of version ids)

space tree: we have a pointer to the first node in a tree. Each node might have some verion, along with some text for that node, as well as an array of pointers to nodes which come after this one. We can read off the whole string using a "pre-order" traversal of the tree.

we initialize the time dag to an empty map.

we initialize the space tree to a pointer to a node which contains no text, and has no children.

now let's insert the letter "a": first we create a unique version id, let's say "version-a". now we just make the root node in the space tree have a child -- a node with version "version-a", the text "a", and no children of it's own.





(they are intended to be read using a "pre-order" traversal of the tree, where each node first outputs it's own text, and then it recursively processes each of it's children in order)


sets where as hashmaps of versions to "true")



Imagine we are syncing text between two machines, like in a google doc.



- layers
    - insertions
    - deletes
    - replaces


- CRDT

- anti-particle algorithm




</pre>

