
<script src="https://dglittle.github.io/cdn/random001.js"></script>
<script src="https://dglittle.github.io/cdn/utils004.js"></script>
<script src="https://invisible-college.github.io/universal-sync/diffsync.js"></script>
<script>

Math.randomSeed(7)

function my_custom_merge_func(a, b, diffs_to_ancestors) {

}

function sync7_diff(a, b) {
    var ret = []
    var d = diff_main(a, b)
    for (var i = 0; i < d.length; i++) {
        if (d[i][0] == 0) {
            ret.push(d[i][1].length)
        } else if (d[i][0] == 1) {
            ret.push(['', d[i][1]])
        } else {
            ret.push([d[i][1], ''])
        }
    }
    return ret
}

function sync7_diff_apply(s, diff) {
    var offset = 0
    var texts = []
    each(diff, function (d) {
        if (typeof(d) == 'number') {
            texts.push(s.substr(offset, d))
            offset += d
        } else {
            texts.push(d[1])
            offset += d[0].length
        }
    })
    texts.push(s.substr(offset))
    return texts.join('')
}

function sync7_diff_merge_trans(a, b, a_factor, b_factor) {
    var ret = []
    var a_i = 0
    var b_i = 0
    var a_offset = 0
    var b_offset = 0
    function neg_idx(i) {
        return i == 0 ? 1 : 0
    }
    function a_idx(i) {
        return a_factor == -1 ? neg_idx(i) : i
    }
    function b_idx(i) {
        return b_factor == -1 ? neg_idx(i) : i
    }
    function push_eq(size) {
        if (typeof(ret[ret.length - 1]) == 'number') {
            ret[ret.length - 1] += size
        } else ret.push(size)
    }
    function push_rep(del, ins) {
        if (del.length == 0 && ins.length == 0) return
        if (ret.length > 0) {
            var top = ret[ret.length - 1]
            if (typeof(top) != 'number') {
                top[0] += del
                top[1] += ins
                return
            }
        }
        ret.push([del, ins])
    }
    while (a_i < a.length && b_i < b.length) {
        var da = a[a_i]
        var db = b[b_i]
        if (typeof(da) == 'number' && typeof(db) == 'number') {
            var a_len = da - a_offset
            var b_len = db - b_offset
            push_eq(Math.min(a_len, b_len))
        } else if (typeof(da) == 'number') {
            var a_len = da - a_offset
            var b_len = db[b_idx(0)].length - b_offset
            push_rep(db[b_idx(0)].substr(b_offset, Math.min(a_len, b_len)), b_offset == 0 ? db[b_idx(1)] : '')
        } else if (typeof(db) == 'number') {
            var a_len = da[a_idx(1)].length - a_offset
            var b_len = db - b_offset
            push_rep(a_offset == 0 ? da[a_idx(0)] : '', da[a_idx(1)].substr(a_offset, Math.min(a_len, b_len)))
        } else {
            var a_len = da[a_idx(1)].length - a_offset
            var b_len = db[b_idx(0)].length - b_offset
            push_rep(a_offset == 0 ? da[a_idx(0)] : '', b_offset == 0 ? db[b_idx(1)] : '')
        }
        if (a_len > b_len) {
            a_offset += b_len
        } else {
            a_i++
            a_offset = 0
        }
        if (a_len < b_len) {
            b_offset += a_len
        } else {
            b_i++
            b_offset = 0
        }
    }
    while (a_i < a.length) {
        push_rep(a_offset == 0 ? da[a_idx(0)] : '', da[a_idx(1)].substr(a_offset))
        a_i++
        a_offset = 0
    }
    while (b_i < b.length) {
        push_rep(db[b_idx(0)].substr(b_offset), b_offset == 0 ? db[b_idx(1)] : '')
        b_i++
        b_offset = 0
    }
    return ret
}

function create_sync7_repo(custom_merge_func) {
    var self = {
        commits : {
            'root' : { to_parents : {} }
        },
        temp_commits : {},
        leaf : 'root',
        text : ''
    }

    self.commit = function (s) {
        if (s == self.text) { return }
        var cs = {}
        
        if (Object.keys(self.temp_commits).length > 1) {
            each(self.temp_commits, function (v, k) {
                cs[k] = v
            })
            self.temp_commits = {}
        }
        
        var id = guid()
        var to_parents = {}
        to_parents[self.leaf] = sync7_diff(s, self.text)
        self.commits[id] = cs[id] = { to_parents : to_parents }
        self.leaf = id
        
        self.text = s
        return cs
    }

    self.merge = function (cs) {
        each(cs, function (c, id) {
            self.commits[id] = c
        })
        var new_temp_commits = {}
        var leaves = get_leaves()
        var leaves = Object.keys(leaves).sort()
        
        var prev_merge_node = leaves[0]
        var prev_merge_node_text = get_text(prev_merge_node)
        var ancestors = get_ancestors(prev_merge_node)
        for (var i = 1; i < leaves.length; i++) {
            var i_ancestors = get_ancestors(leaves[i])
            var LCAs = get_leaves(intersection(ancestors, i_ancestors))
            each(i_ancestors, function (v, k) {
                ancestors[k] = v
            })
            
            var m = custom_merge_func(prev_merge_node_text, get_text(leaves[i]), calc_diffs_to_ancestors(prev_merge_node, leaves[i], LCAs))
            var id = guid()
            new_temp_commits[id] = true
            self.commits[id] = { to_parents : {} }
            self.commits[id].to_parents[prev_merge_node] = m.to_a
            self.commits[id].to_parents[leaves[i]] = m.to_b
            
            prev_merge_node = id
            prev_merge_node_text = m.text
        }
        self.leaf = prev_merge_node
        self.text = prev_merge_node_text
        
        each(self.temp_commits, function (_, k) {
            delete self.commits[k]
        })
        self.temp_commits = new_temp_commits
    }
    
    function calc_diffs_to_ancestors(a, b, LCAs) {
        var diffs = []
        each(LCAs, function (_, lca) {
            diffs.push([
                calc_diff_to_ancestor(a, lca),
                calc_diff_to_ancestor(b, lca)
            ])
        })
        return diffs
    }
    
    function calc_diff_to_ancestor(x, ancestor) {
        var diff = []
        var prev = x
        each(get_path_to_ancestor(x, ancestor), function (next) {
            diff = sync7_diff_merge_trans(diff, self.commits[prev].to_parents[next])
            prev = next
        })
        return diff
    }
    
    function get_text(id) {
        var ls = get_leaves(intersection(get_ancestors(self.leaf), get_ancestors(id)))
        var lca = Object.keys(ls)[0]
        var leaf_to_lca = get_path_to_ancestor(self.leaf, lca)
        var lca_to_id = get_path_to_ancestor(id, lca).reverse()
        if (lca_to_id.length > 0) {
            lca_to_id.shift()
            lca_to_id.push(id)
        }
        
        var diff = []
        var prev = leaf
        each(leaf_to_lca, function (next) {
            diff = sync7_diff_merge_trans(diff, self.commits[prev].to_parents[next])
            prev = next
        })
        each(lca_to_id, function (next) {
            diff = sync7_diff_merge_trans(diff, self.commits[next].to_parents[prev], 1, -1)
            prev = next
        })
        
        return sync7_diff_apply(self.text, diff)
    }

    
    function get_leaves(commits) {
        if (!commits) commits = self.commits
        var leaves = {}
        each(commits, function (_, id) { leaves[id] = true })
        each(commits, function (c) {
            each(c.to_parents, function (_, p) {
                delete leaves[p]
            })
        })
        return leaves
    }
    
    function get_ancestors(id) {
        var frontier = [id]
        var ancestors = {}
        while (frontier.length > 0) {
            var next = frontier.shift()
            each(self.commits[next].to_parents, function (_, p) {
                if (!ancestors[p]) {
                    ancestors[p] = self.commits[p]
                    frontier.push(p)
                }
            })
        }
        return ancestors
    }
    
    function get_path_to_ancestor(a, b) {
        if (a == b) { return [] }
        var frontier = [a]
        var backs = {}
        while (frontier.length > 0) {
            var next = frontier.shift()
            if (next == b) {
                var path = []
                while (next && (next != a)) {
                    path.unshift(next)
                    next = backs[next]
                }
                return path
            }
            each(self.commits[next].to_parents, function (_, p) {
                if (!backs[p]) {
                    backs[p] = next
                    frontier.push(p)
                }
            })
        }
        throw 'no path found from ' + a + ' to ' + b
    }

    function intersection(a, b) {
        var common = {}
        each(a, function (_, x) {
            if (b[x]) {
                common[x] = a[x]
            }
        })
        return common
    }

    return self
}

var repoA = create_sync7_repo(my_custom_merge_func)

repoA.commits['a0'] = {
    to_parents : {
        'root' : [0]
    },
    text : 'x'
}
repoA.commits['a1'] = {
    to_parents : {
        'a0' : [0.5, 1]
    },
    text : 'xz'
}
repoA.commits['b1'] = {
    to_parents : {
        'a0' : [-0.5]
    },
    text : 'y'
}
repoA.commits['a2'] = {
    to_parents : {
        'a1' : [-0.5, 1.5],
        'b1' : [0.5, 1]
    },
    text : 'yz'
}
repoA.commits['b2'] = {
    to_parents : {
        'b1' : [-0.5]
    },
    text : 'q'
}
repoA.commits['b3'] = {
    to_parents : {
        'a1' : [-0.5, 1.5],
        'b2' : [0.5, 1]
    },
    text : 'qz'
}

repoA.merge({})
console.log(JSON.stringify(repoA, null, '    '))

</script>
