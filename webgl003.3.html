<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.6.1/gl-matrix-min.js"></script>
<body></body>
<script>

throw 'stop'

var dpr = window.devicePixelRatio

var size = 100

var c = document.createElement('canvas')
c.width = size
c.height = size
c.style.width = c.width / dpr + 'px'
c.style.height = c.height / dpr + 'px'
c.style['image-rendering'] = 'pixelated'
document.body.append(c)
var gl = c.getContext('webgl2')
gl.getExtension('EXT_color_buffer_float')

var cc = document.createElement('canvas')
cc.width = size * 3
cc.height = 1
cc.style.width = cc.width / dpr + 'px'
cc.style.height = cc.height / dpr + 'px'
cc.style['image-rendering'] = 'pixelated'
document.body.append(cc)
var g2 = cc.getContext('webgl2')
g2.getExtension('EXT_color_buffer_float')

var vs = createShader(gl, gl.VERTEX_SHADER, `#version 300 es
in vec4 a_position;
void main() {
    gl_Position = a_position;
}
`)

var fs_draw = createShader(gl, gl.FRAGMENT_SHADER, `#version 300 es
precision mediump float;

uniform sampler2D in_pos;

out vec4 out_color;

float lerp(float t0, float v0, float t1, float v1, float t) {
    return (t - t0) * (v1 - v0) / (t1 - t0) + v0;
}

void main() {
    const float PI = 3.1415926535897932384626433832795;
    vec4 p = texture(in_pos, vec2((gl_FragCoord.y * float(${size}) + gl_FragCoord.x) / float(${Math.pow(size, 3)}), 0));
    out_color.r = lerp(-1.0, 0.0, 1.0, 1.0, p.x);
    out_color.g = lerp(-1.0, 0.0, 1.0, 1.0, p.y);
    out_color.b = lerp(-1.0, 0.0, 1.0, 1.0, p.z);
    out_color.a = 1.0;
}

`)

var program_draw = createProgram(gl, vs, fs_draw)
gl.useProgram(program_draw)
var a_position = gl.getAttribLocation(program_draw, 'a_position')

var positionBuffer = gl.createBuffer()

gl.uniform1i(gl.getUniformLocation(program_draw, 'in_pos'), 0)

gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
    -1, 3,
    3, -1,
]), gl.STATIC_DRAW)

gl.enableVertexAttribArray(a_position)

gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0)

function create_texture(rand) {
    var f = new Float32Array(Math.pow(size, 3) * 4)
    if (rand) {
        for (var i = 0; i < f.length; i += 4) {
            var v = vec3.random(vec3.create())
            f[i + 0] = v[0]
            f[i + 1] = v[1]
            f[i + 2] = v[2]
            f[i + 3] = 1
        }
    }
    
    var tex = gl.createTexture()
    
    gl.bindTexture(gl.TEXTURE_2D, tex)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, Math.pow(size, 3), 1, 0, gl.RGBA, gl.FLOAT, f)
    
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    
    return tex
}

var E_tex = create_texture(true)

var fb_to_a = gl.createFramebuffer()
gl.bindFramebuffer(gl.FRAMEBUFFER, fb_to_a)
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, E_tex, 0)

loop()
function loop() {
    gl.bindTexture(gl.TEXTURE_2D, E_tex)
    
    gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    gl.useProgram(program_draw)
    gl.drawArrays(gl.TRIANGLES, 0, 3)
    
    //setTimeout(loop, 1000)
    window.requestAnimationFrame(loop)
}




function createShader(gl, type, source) {
    var shader = gl.createShader(type)
    gl.shaderSource(shader, source)
    gl.compileShader(shader)
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader
    console.log(gl.getShaderInfoLog(shader))
    gl.deleteShader(shader)
}

function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram()
    gl.attachShader(program, vertexShader)
    gl.attachShader(program, fragmentShader)
    gl.linkProgram(program)
    if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program
    console.log(gl.getProgramInfoLog(program))
    gl.deleteProgram(program)
}

</script>
