
<script src="https://dglittle.github.io/cdn/random001.js"></script>
<script src="https://dglittle.github.io/cdn/utils004.js"></script>
<script src="https://invisible-college.github.io/universal-sync/diffsync.js"></script>
<script>

Math.randomSeed(7)

function my_custom_merge_func() {
    console.log('what do you want from me!?')
    throw 'bad'
}

function create_sync7_repo() {
    return {
        commits : {
            'root' : { to_parents : {}, from_kids : {} }
        },
        temp_commits : {},
        leaf : 'root',
        text : ''
    }
}

function sync7_commit(s7, s) {
    if (s == s7.text) { return }
    
    var cs = s7.temp_commits
    s7.temp_commits = {}

    var id = guid()
    var to_parents = {}
    s7.commits[s7.leaf].from_kids[id] = to_parents[s7.leaf] = sync7_diff(s, s7.text)
    s7.commits[id] = cs[id] = { to_parents : to_parents, from_kids : {} }
    s7.leaf = id
    
    s7.text = s
    return cs
}

function sync7_merge(s7, cs, custom_merge_function) {
    each(cs, function (c, id) {
        s7.commits[id] = c
        each(c.to_parents, function (d, p) {
            if (!cs[p] && s7.commits[p]) {
                s7.commits[p].from_kids[id] = d
            }
        })
    })
    var leaves = sync7_get_leaves(s7.commits, s7.temp_commits)
    leaves = Object.keys(leaves).sort()
    
    var texts = {}
    each(leaves, function (leaf) {
        texts[leaf] = sync7_get_text(s7, leaf)
    })

    each(s7.temp_commits, function (_, k) {
        delete s7.commits[k]
    })
    s7.temp_commits = {}
    
    var prev_merge_node = leaves[0]
    var prev_merge_node_text = texts[prev_merge_node]
    var ancestors = sync7_get_ancestors(s7, prev_merge_node)
    for (var i = 1; i < leaves.length; i++) {
        var leaf = leaves[i]
        var i_ancestors = sync7_get_ancestors(s7, leaf)
        var CAs = sync7_intersection(ancestors, i_ancestors)
        var LCAs = sync7_get_leaves(CAs)
        each(i_ancestors, function (v, k) {
            ancestors[k] = v
        })
        
        function get_nodes_on_path_to_LCAs(node) {
            var agg = {}
            function helper(x) {
                var hit_LCA = LCAs[x]
                if (!CAs[x]) {
                    each(s7.commits[x].to_parents, function (d, p) {
                        hit_LCA = hit_LCA || helper(p)
                    })
                }
                if (hit_LCA) {
                    agg[x] = true
                    return true
                }
            }
            helper(node)
            return agg
        }

        function get_regions_for_node(node, nodes_on_path_to_LCAs) {
            var dividers = {}
            var untouched_regions_for_node = {}
            untouched_regions_for_node[node] = [[0, texts[node].length, 0]]
            function helper(node) {
                var untouched = Object.values(untouched_regions_for_node[node]).sort(function (a, b) { return a[2] - b[2] })
                untouched_regions_for_node[node] = true
                var c = s7.commits[node]
                each(c.to_parents, function (d, p) {
                    if (!nodes_on_path_to_LCAs[p]) { return }
                    
                    var ui = 0
                    var uo = 0
                    var pur = untouched_regions_for_node[p] =
                        untouched_regions_for_node[p] || {}
                    var offset = 0
                    var poffset = 0
                    each(d, function (r) {
                        var end_point = offset + ((typeof(r) == 'number') ? r : r[0].length)
                        while (untouched[ui] && end_point >= untouched[ui][2] + untouched[ui][1]) {
                            if (typeof(r) == 'number') {
                                var x = untouched[ui][2] + uo - offset + poffset
                                pur[x] = [untouched[ui][0] + uo, untouched[ui][1] - uo, x]
                            }
                            ui++
                            uo = 0
                        }
                        if (!untouched[ui]) { return false }
                        if (end_point <= untouched[ui][2] + uo) { return }
                        if (typeof(r) == 'number') {
                            var x = untouched[ui][2] + uo - offset + poffset
                            pur[x] = [untouched[ui][0] + uo, end_point - (untouched[ui][2] + uo), x]
                        }
                        uo = end_point - untouched[ui][2]
                        dividers[untouched[ui][0] + uo] = untouched[ui][0] + uo
                    })
                    
                    var parent_ready_to_go = true
                    each(s7.commits[p].from_kids, function (d, k) {
                        if (untouched_regions_for_node[k] !== true) {
                            parent_ready_to_go = false
                            return false
                        }
                    })
                    if (parent_ready_to_go) helper(p)
                })
            }
            helper(node)
            
            var regions = []
            var prev_offset = 0
            each(Object.values(dividers).sort(), function (offset) {
                regions.push([prev_offset, offset])
                prev_offset = offset
            })
            regions.push([prev_offset, texts[node].length])
            
            return regions
        }
        
        function project_regions_to_LCAs(node) {
            var nodes_on_path_to_LCAs = get_nodes_on_path_to_LCAs(node)
            var regions_for_node = {}
            regions_for_node[node] = get_regions_for_node(node, nodes_on_path_to_LCAs)
            
            function helper(node) {
                if (regions_for_node[node]) return regions_for_node[node]
                var final_regions = []
                each(s7.commits[node].from_kids, function (d, k) {
                    if (!nodes_on_path_to_LCAs[k]) { return }
                    each(helper(k), function (r) {
                        
                        project up one level,
                        and add in a min/max way to final_regions
                        
                    })
                })
                
                for each child,
                    get it's regions
                and then accumulate these regions (min/max)
            }
            
            each(LCAs, function (_, lca) {
                helper(lca)
            })
            
            
            
            
            
            
            
            
            
            
            
            
            untouched_regions_for_node[node] = [[0, texts[node].length, 0]]
            function helper(node) {
                var untouched = Object.values(untouched_regions_for_node[node]).sort(function (a, b) { return a[2] - b[2] })
                untouched_regions_for_node[node] = true
                var c = s7.commits[node]
                each(c.to_parents, function (d, p) {
                    if (!nodes_on_path_to_LCAs[p]) { return }
                    
                    var ui = 0
                    var uo = 0
                    var pur = untouched_regions_for_node[p] =
                        untouched_regions_for_node[p] || {}
                    var offset = 0
                    var poffset = 0
                    each(d, function (r) {
                        var end_point = offset + ((typeof(r) == 'number') ? r : r[0].length)
                        while (untouched[ui] && end_point >= untouched[ui][2] + untouched[ui][1]) {
                            if (typeof(r) == 'number') {
                                var x = untouched[ui][2] + uo - offset + poffset
                                pur[x] = [untouched[ui][0] + uo, untouched[ui][1] - uo, x]
                            }
                            ui++
                            uo = 0
                        }
                        if (!untouched[ui]) { return false }
                        if (end_point <= untouched[ui][2] + uo) { return }
                        if (typeof(r) == 'number') {
                            var x = untouched[ui][2] + uo - offset + poffset
                            pur[x] = [untouched[ui][0] + uo, end_point - (untouched[ui][2] + uo), x]
                        }
                        uo = end_point - untouched[ui][2]
                        dividers[untouched[ui][0] + uo] = untouched[ui][0] + uo
                    })
                    
                    var parent_ready_to_go = true
                    each(s7.commits[p].from_kids, function (d, k) {
                        if (untouched_regions_for_node[k] !== true) {
                            parent_ready_to_go = false
                            return false
                        }
                    })
                    if (parent_ready_to_go) helper(p)
                })
            }
            helper(node)
            
            var regions = []
            var prev_offset = 0
            each(Object.values(dividers).sort(), function (offset) {
                regions.push([prev_offset, offset])
                prev_offset = offset
            })
            regions.push([prev_offset, texts[node].length])
            
            return regions
        }
























    
        console.log('BLOOP!')
        console.log('prev_regions = ', prev_regions)
        console.log('leaf_regions = ', leaf_regions)

        throw 'bloop'
        
        
        
        
        
        // var paths = {}
        // path_so_far = []
        // function find_paths_up_to_LCAs(a) {
        //     if (LCAs[a]) {
        //         if (!paths[a]) paths[a] = []
        //         paths[a].push(path_so_far.slice(0))
        //     } else {
        //         each(s7.commits[a].to_parents, function (d, p) {
        //             if (LCAs[p] || !CAs[p]) {
        //                 path_so_far.push(p)
        //                 find_paths_up_to_LCAs(p)
        //                 path_so_far.pop()
        //             }
        //         })
        //     }
        // }
        // find_paths_up_to_LCAs(prev_merge_node)
        // var prev_paths = paths
        // paths = {}
        // path_so_far = []
        // find_paths_up_to_LCAs(leaf)
        // var leaf_paths = paths
        
        // each(prev_paths, function (paths, dest) {
            
            
            
            
            
        //     prev_paths[dest] = sync7_merge_path_up(s7, prev_merge_node, )
        // })





// sync7_merge_path_up




// work here        
//     var diff = []
//     var prev = s7.leaf
//     each(leaf_to_lca, function (next) {
//         diff = sync7_diff_merge_trans(diff, s7.commits[prev].to_parents[next])
//         prev = next
//     })

        
        
        
//         each([prev_merge_node, leaves[i]], function (leaf) {
//             var regions = []
//             each(s7.commits[leaf].to_parents, function (d, p) {
//                 each(d, function (d, i) {
//                     regions[i] = 
//                 })
//             })
            
            
            
            
            
            
            
            
//             // follow each region up to all parents,
//                 if we encounter an LCA,
//                     deal with that,
//                 if we encounter a member of sync7_intersection,
//                     we've gone too far
//                 otherwise,
//                     continue following parents up
        // })
        
        
        
        
        
        
        
        
        
        // var m = custom_merge_func(prev_merge_node_text, texts[leaves[i]], sync7_calc_diffs_to_ancestors(s7, prev_merge_node, leaves[i], LCAs))
        // var id = guid()
        // s7.temp_commits[id] = true
        // s7.commits[id] = { to_parents : {} }
        // s7.commits[id].to_parents[prev_merge_node] = m.to_a
        // s7.commits[id].to_parents[leaves[i]] = m.to_b
        
        // prev_merge_node = id
        // prev_merge_node_text = m.text
        
        
        
        
        
        
        
        
    }

    s7.leaf = prev_merge_node
    s7.text = prev_merge_node_text
}

function sync7_diff_merge_trans(a, b, a_factor, b_factor) {
    var ret = []
    var a_i = 0
    var b_i = 0
    var a_offset = 0
    var b_offset = 0
    function neg_idx(i) {
        return i == 0 ? 1 : 0
    }
    function a_idx(i) {
        return a_factor == -1 ? neg_idx(i) : i
    }
    function b_idx(i) {
        return b_factor == -1 ? neg_idx(i) : i
    }
    while (a_i < a.length && b_i < b.length) {
        var da = a[a_i]
        var db = b[b_i]
        if (typeof(da) == 'number' && typeof(db) == 'number') {
            var a_len = da - a_offset
            var b_len = db - b_offset
            sync7_push_eq(ret, Math.min(a_len, b_len))
        } else if (typeof(da) == 'number') {
            var a_len = da - a_offset
            var b_len = db[b_idx(0)].length - b_offset
            sync7_push_rep(ret, db[b_idx(0)].substr(b_offset, Math.min(a_len, b_len)), b_offset == 0 ? db[b_idx(1)] : '')
        } else if (typeof(db) == 'number') {
            var a_len = da[a_idx(1)].length - a_offset
            var b_len = db - b_offset
            sync7_push_rep(ret, a_offset == 0 ? da[a_idx(0)] : '', da[a_idx(1)].substr(a_offset, Math.min(a_len, b_len)))
        } else {
            var a_len = da[a_idx(1)].length - a_offset
            var b_len = db[b_idx(0)].length - b_offset
            sync7_push_rep(ret, a_offset == 0 ? da[a_idx(0)] : '', b_offset == 0 ? db[b_idx(1)] : '')
        }
        if (a_len > b_len) {
            a_offset += b_len
        } else {
            a_i++
            a_offset = 0
        }
        if (a_len < b_len) {
            b_offset += a_len
        } else {
            b_i++
            b_offset = 0
        }
    }
    while (a_i < a.length) {
        var da = a[a_i]
        if (typeof(da) == 'number') {
            sync7_push_eq(ret, da)
        } else {
            sync7_push_rep(ret, a_offset == 0 ? da[a_idx(0)] : '', da[a_idx(1)].substr(a_offset))
        }
        a_i++
        a_offset = 0
    }
    while (b_i < b.length) {
        var db = b[b_i]
        if (typeof(db) == 'number') {
            sync7_push_eq(ret, db)
        } else {
            sync7_push_rep(ret, db[b_idx(0)].substr(b_offset), b_offset == 0 ? db[b_idx(1)] : '')
        }
        b_i++
        b_offset = 0
    }
    return ret
}

function sync7_merge_path_up(s7, from, path) {
    var diff = []
    var prev = from
    each(path, function (next) {
        diff = sync7_diff_merge_trans(diff, s7.commits[prev].to_parents[next])
        prev = next
    })
    return diff
}


function sync7_get_text(s7, id) {
    var ls = sync7_get_leaves(sync7_intersection(sync7_get_ancestors(s7, s7.leaf, true), sync7_get_ancestors(s7, id, true)))
    var lca = Object.keys(ls)[0]
    var leaf_to_lca = sync7_get_path_to_ancestor(s7, s7.leaf, lca)
    var lca_to_id = sync7_get_path_to_ancestor(s7, id, lca).reverse()
    if (lca_to_id.length > 0) {
        lca_to_id.shift()
        lca_to_id.push(id)
    }
    
    var diff = sync7_merge_path_up(s7, s7.leaf, leaf_to_lca)
    var prev = lca
    each(lca_to_id, function (next) {
        diff = sync7_diff_merge_trans(diff, s7.commits[next].to_parents[prev], 1, -1)
        prev = next
    })
    
    return sync7_diff_apply(s7.text, diff)
}
    
function sync7_get_leaves(commits, ignore) {
    if (!ignore) ignore = {}
    var leaves = {}
    each(commits, function (_, id) {
        if (ignore[id]) { return }
        leaves[id] = true
    })
    each(commits, function (c, id) {
        if (ignore[id]) { return }
        each(c.to_parents, function (_, p) {
            delete leaves[p]
        })
    })
    return leaves
}
    
function sync7_get_ancestors(s7, id, include_self) {
    var frontier = [id]
    var ancestors = {}
    if (include_self)
        ancestors[id] = s7.commits[id]
    while (frontier.length > 0) {
        var next = frontier.shift()
        each(s7.commits[next].to_parents, function (_, p) {
            if (!ancestors[p]) {
                ancestors[p] = s7.commits[p]
                frontier.push(p)
            }
        })
    }
    return ancestors
}

function sync7_get_path_to_ancestor(s7, a, b) {
    if (a == b) { return [] }
    var frontier = [a]
    var backs = {}
    while (frontier.length > 0) {
        var next = frontier.shift()
        if (next == b) {
            var path = []
            while (next && (next != a)) {
                path.unshift(next)
                next = backs[next]
            }
            return path
        }
        each(s7.commits[next].to_parents, function (_, p) {
            if (!backs[p]) {
                backs[p] = next
                frontier.push(p)
            }
        })
    }
    throw 'no path found from ' + a + ' to ' + b
}

function sync7_intersection(a, b) {
    var common = {}
    each(a, function (_, x) {
        if (b[x]) {
            common[x] = a[x]
        }
    })
    return common
}

function sync7_diff(a, b) {
    var ret = []
    var d = diff_main(a, b)
    for (var i = 0; i < d.length; i++) {
        var top = ret[ret.length - 1]
        if (d[i][0] == 0) {
            ret.push(d[i][1].length)
        } else if (d[i][0] == 1) {
            if (top && (typeof(top) != 'number'))
                top[1] += d[i][1]
            else
                ret.push(['', d[i][1]])
        } else {
            if (top && (typeof(top) != 'number'))
                top[0] += d[i][1]
            else
                ret.push([d[i][1], ''])
        }
    }
    return ret
}

function sync7_push_eq(diffs, size) {
    if (typeof(diffs[diffs.length - 1]) == 'number') {
        diffs[diffs.length - 1] += size
    } else diffs.push(size)
}

function sync7_push_rep(diffs, del, ins) {
    if (del.length == 0 && ins.length == 0) { return }
    if (diffs.length > 0) {
        var top = diffs[diffs.length - 1]
        if (typeof(top) != 'number') {
            top[0] += del
            top[1] += ins
            return
        }
    }
    diffs.push([del, ins])
}

function sync7_diff_apply(s, diff) {
    var offset = 0
    var texts = []
    each(diff, function (d) {
        if (typeof(d) == 'number') {
            texts.push(s.substr(offset, d))
            offset += d
        } else {
            texts.push(d[1])
            offset += d[0].length
        }
    })
    texts.push(s.substr(offset))
    return texts.join('')
}

var repoA = create_sync7_repo()
var repoB = create_sync7_repo()
var c_x = sync7_commit(repoA, 'x')
sync7_merge(repoB, c_x, my_custom_merge_func)
var c_xz = sync7_commit(repoA, 'xz')
var c_y = sync7_commit(repoB, 'y')

console.log('AAA------------------------')
console.log(JSON.stringify(repoA, null, '    '))
console.log('BBB------------------------')
console.log(JSON.stringify(repoB, null, '    '))

sync7_merge(repoA, c_y, my_custom_merge_func)
// var c_q = sync7_commit(repoB, 'q')
// sync7_merge(repoB, c_xz, my_custom_merge_func)
// var c_yzA = sync7_commit(repoA, 'yzA')
// var c_qzB = sync7_commit(repoB, 'qzB')
// sync7_merge(repoA, c_q, my_custom_merge_func)
// sync7_merge(repoA, c_qzB, my_custom_merge_func)

</script>
