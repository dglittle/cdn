
<script src="https://dglittle.github.io/cdn/random001.js"></script>
<script src="https://dglittle.github.io/cdn/utils004.js"></script>
<script src="https://invisible-college.github.io/universal-sync/diffsync.js"></script>
<body></body>
<script>

function sync9_create() {
    return {
        T : { 'root' : {} },
        leaves : { 'root' : true },
        val : sync9_create_val()
    }
}

function sync9_add_version(x, vid, parents, changes) {
    x.T[vid] = parents == x.leaves ? Object.assign({}, x.leaves) : parents
    
    Object.keys(parents).forEach((k) => {
        if (x.leaves[k])
            delete x.leaves[k]
    })
    x.leaves[vid] = true
    
    var is_anc = null
    if (parents == x.leaves) {
        is_anc = (_vid) => {
            return _vid != vid
        }
    } else {
        var ancs = {}
        function mark_ancs(key) {
            if (!ancs[key]) {
                ancs[key] = true
                Object.keys(x.T[key]).forEach(k => mark_ancs(k))
            }
        }
        Object.keys(parents).forEach(k => mark_ancs(k))
        is_anc = _vid => ancs[_vid]
    }
    
    changes.forEach(change => {
        var parse = sync9_parse_change(change)
        var cur = x.T.val
        each(parse.keys, (key, i) => {
            var val = sync9_space_dag_get(cur.S, 0, is_anc)
            if (!val) throw 'bad'
            if (typeof(key) == 'string' && val.t == 'obj') {
                if (!val.S[key]) val.S[key] = sync9_create_val()
                cur = val.S[key]
            } else if (typeof(key) == 'number' && val.t == 'arr') {
                cur = sync9_space_dag_get(val.S, key, is_anc)
                
                
                work here
                
                
                
                if (!cur) throw 'bad'
            } else if (typeof(key) == 'number' && cur.val.t == 'str') {
                if (i != parse.keys.length - 1) throw 'bad'
                parse.range = [key, key + 1]
            } else throw 'bad'
        })
        if (cur) {
            if (parse.range && (parse.val instanceof Array) && cur.val && cur.val.t == 'arr') {
                sync9_arr_add_version(cur.val, vid, parents, [[parse.range[0], parse.range[1] - parse.range[0], parse.val]], is_anc)
            } else if (parse.range && (parse.val instanceof String) && cur.val && cur.val.t == 'str') {
                sync9_str_add_version(cur.val, vid, parents, [[parse.range[0], parse.range[1] - parse.range[0], parse.val]], is_anc)
            } else if (!parse.range) {
                sync9_val_add_version(cur, vid, parents, parse.val)
            } else throw 'bad'
        }
    })
}

function sync9_read(x) {
    return sync9_val_read(x.val)
}


function sync9_create_val() {
    return {
        t : 'val',
        S : sync9_create_space_dag_node('root', [])
    }
}

function sync9_create_obj() {
    return {
        t : 'obj',
        S : {}
    }
}

function sync9_create_arr() {
    return {
        t : 'arr',
        S : sync9_create_space_dag_node('root', [])
    }
}

function sync9_create_str() {
    return {
        t : 'str',
        S : sync9_create_space_dag_node('root', '')
    }
}


function sync9_val_read(x) {
    var val = sync9_space_dag_get(x.S, 0)
    if (!val) return
    if (val.t == 'lit') return val.val
    if (val.t == 'val') throw 'bad'
    if (val.t == 'obj') return sync9_obj_read(val)
    if (val.t == 'arr') return sync9_arr_read(val)
    if (val.t == 'str') return sync9_str_read(val)
}

function sync9_obj_read(x) {
    var o = {}
    Object.entries(x.S).forEach(([k, v]) => {
        o[k] = sync9_val_read(v)
    })
    return o
}

function sync9_arr_read(x) {
    var a = []
    sync9_trav_space_dag(x.S, () => true, (node) => {
        node.elems.forEach((e) => {
            a.push(sync9_val_read(e))
        })
    })
    return a
}

function sync9_str_read(x) {
    var s = []
    sync9_trav_space_dag(x.S, () => true, (node) => {
        s.push(node.elems)
    })
    return s.join('')
}


function sync9_arr_add_version(x, vid, parents, changes, is_anc) {
}

function sync9_str_add_version(x, vid, parents, changes, is_anc) {
}


function sync9_space_dag_get(x, i, is_anc) {
    var ret = null
    var offset = 0
    sync9_trav_space_dag(x, is_anc ? is_anc : () => true, (node) => {
        if (i - offset < node.elems.length) {
            ret = node.elems[i - offset]
            return false
        }
        offset += node.elems.length
    })
    return ret
}


function sync9_parse_change(change) {
    var ret = { keys : [] }
    
    var re = /\.?([^\.\[ =]+)|\[((\-?\d+)(:\-?\d+)?|'(\\'|[^'])*'|"(\\"|[^"])*")\]|\s*=\s*(.*)/g
    var m
    while (m = re.exec(change)) {
        if (m[1])
            ret.keys.push(m[1])
        else if (m[2] && m[4])
            ret.range = [
                JSON.parse(m[3]),
                JSON.parse(m[4].substr(1))
            ]
        else if (m[2])
            ret.keys.push(JSON.parse(m[2]))
        else if (m[7])
            ret.val = JSON.parse(m[7])
    }
    
    return ret
}










function sync9_create_space_dag_node(vid, elems, start, stop) {
    if (start === undefined) {
        start = 0
        stop = elems.length * 2
    }
    return {
        vid : vid,
        elems : elems,
        start : start,
        stop : stop,
        
        nexts : [],
        next : null,
        prev : null,
        
        deleted_by : {}
    }
}

function sync9_space_dag_add_version(x, vid, parents, splices, is_anc) {
    
    function subseq(x, start, stop) {
        return (x instanceof Array) ?
            x.slice(start, stop) :
            x.substring(start, stop)
    }
    
    function add_outgoing(add_to, loc, outgoing_to) {
        if (loc < add_to.stop) {
            var elems_divide = add_to.elems.length - ((add_to.stop + (add_to.stop % 2 == 0 ? 1 : 0) - loc) >> 1)
            
            var tail = sync9_create_space_dag_node(add_to.vid, subseq(add_to.elems, elems_divide), loc + 1, add_to.stop)
            
            tail.nexts = add_to.nexts
            tail.next = add_to.next
            if (tail.next) tail.next.prev = tail
            tail.prev = add_to
            
            add_to.stop = loc
            add_to.elems = subseq(add_to.elems, 0, elems_divide)
            add_to.nexts = [outgoing_to]
            add_to.next = tail
        } else {
            var i = binarySearch(add_to.nexts, function (x) {
                if (outgoing_to.vid < x.vid) return -1
                if (outgoing_to.vid > x.vid) return 1
                return 0
            })
            add_to.nexts.splice(i, 0, outgoing_to)
        }
    }
    
    function add_incoming(add_to, loc) {
        if (loc > add_to.start) {
            var elems_divide = add_to.elems.length - ((add_to.stop + (add_to.stop % 2 == 0 ? 2 : 1) - loc) >> 1)
            
            var tail = sync9_create_space_dag_node(add_to.vid, subseq(add_to.elems, text_divide), loc, add_to.stop)
            tail.nexts = add_to.nexts
            tail.next = add_to.next
            if (tail.next) tail.next.prev = tail
            tail.prev = add_to
            
            add_to.stop = loc - 1
            add_to.elems = subseq(add_to.elems, 0, elems_divide)
            add_to.nexts = []
            add_to.next = tail
        }
    }

    var si = 0
    var delete_up_to = 0
    
    sync9_trav_space_dag(x.S, is_anc, (node, offset, has_nexts) => {
        var s = splices[si]
        if (!s) return false
        
        if (s[1] == 0) {
            if (s[0] > offset + node.elems.length) return
            
            var insert_location = (s[0] == offset) ? node.start : node.stop - ((offset + node.elems.length - s[0]) * 2) + (node.stop % 2 == 0 ? 0 : -1)
            
            if (insert_location == node.stop && has_nexts) return
            
            add_outgoing(node, insert_location, sync9_create_space_dag_node(vid, s[2]))
            si++
            return
        }
        
        if (delete_up_to <= offset) {
            if (s[0] >= offset + node.elems.length) return
            
            var insert_location = node.stop - ((offset + node.elems.length - s[0]) * 2) + (node.stop % 2 == 0 ? 1 : 0)
            
            delete_up_to = s[0] + s[1]
            
            if (insert_location < node.start) {
                add_outgoing(node.prev, node.prev.stop, sync9_create_space_dag_node(vid, s[2]))
            } else {
                add_outgoing(node, insert_location, sync9_create_space_dag_node(vid, s[2]))
                return
            }
        }
        
        if (delete_up_to > offset) {
            node.deleted_by[vid] = true
            if (delete_up_to > offset + node.elems.length) return
            
            if (delete_up_to < offset + node.elems.length) {
                add_incoming(node, node.stop - ((offset + node.elems.length - delete_up_to) * 2) + (node.stop % 2 == 0 ? 1 : 0))
            }
            
            si++
            return
        }
    })
}

function sync9_trav_space_dag(S, f, cb) {
    var offset = 0
    function helper(node) {
        var has_nexts = false
        each(node.nexts, (next) => {
            if (f(next)) {
                has_nexts = true
                return false
            }
        })
        
        var deleted = false
        each(node.deleted_by, (vid) => {
            if (f(vid)) {
                deleted = true
                return false
            }
        })
        
        if (!deleted) {
            cb(node, offset, has_nexts)
            offset += node.elems.length
        }
            
        each(node.nexts, (next) => {
            if (f(next)) helper(next)
        })
        if (node.next) helper(node.next)
    }
    helper(S)
}

function sync9_diff_ODI(a, b) {
    var offset = 0
    var prev = null
    var ret = []
    var d = diff_main(a, b)
    for (var i = 0; i < d.length; i++) {
        if (d[i][0] == 0) {
            if (prev) ret.push(prev)
            prev = null
            offset += d[i][1].length
        } else if (d[i][0] == 1) {
            if (prev)
                prev[2] += d[i][1]
            else
                prev = [offset, 0, d[i][1]]
        } else {
            if (prev)
                prev[1] += d[i][1].length
            else
                prev = [offset, d[i][1].length, '']
            offset += d[i][1].length
        }
    }
    if (prev) ret.push(prev)
    return ret
}

// modified from https://stackoverflow.com/questions/22697936/binary-search-in-javascript
function binarySearch(ar, compare_fn) {
    var m = 0;
    var n = ar.length - 1;
    while (m <= n) {
        var k = (n + m) >> 1;
        var cmp = compare_fn(ar[k]);
        if (cmp > 0) {
            m = k + 1;
        } else if(cmp < 0) {
            n = k - 1;
        } else {
            return k;
        }
    }
    return m;
}

</script>
